<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>C# Asynchronous programming #2</title><meta name="description" content="while(true) me.Learn();"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/tom.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
C# Asynchronous programming #2ThreadThread Safety
本地状态与共享状态
Local 本地独立：CLR为每个线程分配自己的内存栈，以便使本地变量保持独立
Shared 共享：如果多个线程引用到了同一个对象实例，那么他们就共享了数据；被Lambad表达式或匿名委托捕获的本地变量，会被编译器转化为字段（field），所以也会被共享；静态字段也会在线程间共享



class Program
{
    
    static void Main(string[] args)
    {
        /*本地变量不共享*/
        //打印六次hello...
        Thread thread = new Thread(GO);
       .."><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Xavier's blog" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Xavier's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">C# Asynchronous programming #2</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/aloha">aloha</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/aloha">aloha</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-Asynchronous-programming-2"><span class="toc-text">C# Asynchronous programming #2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread"><span class="toc-text">Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-Safety"><span class="toc-text">Thread Safety</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transfer-Parameter"><span class="toc-text">Transfer Parameter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception"><span class="toc-text">Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foreground-Threads-and-Background-Threads"><span class="toc-text">Foreground Threads and Background Threads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Priority-of-Threading"><span class="toc-text">Priority of Threading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Signaling"><span class="toc-text">Signaling</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Asynchronous-programming"><i class="tag post-item-tag">Asynchronous-programming</i></a><a href="/tags/CS-Threading"><i class="tag post-item-tag">CS-Threading</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">C# Asynchronous programming #2</h1><time class="has-text-grey" datetime="2021-11-22T08:36:10.315Z">2021-11-22</time><article class="mt-2 post-content"><p><img src="/images/CSAsynchronousProgramming/cover.png" alt="$cover"></p>
<h1 id="C-Asynchronous-programming-2"><a href="#C-Asynchronous-programming-2" class="headerlink" title="C# Asynchronous programming #2"></a>C# Asynchronous programming #2</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><strong>Thread</strong></h2><h3 id="Thread-Safety"><a href="#Thread-Safety" class="headerlink" title="Thread Safety"></a><strong>Thread Safety</strong></h3><ul>
<li>本地状态与共享状态<ul>
<li>Local 本地独立：CLR为每个线程分配自己的内存栈，以便使本地变量保持独立</li>
<li>Shared 共享：如果多个线程引用到了同一个对象实例，那么他们就共享了数据；被Lambad表达式或匿名委托捕获的本地变量，会被编译器转化为字段（field），所以也会被共享；静态字段也会在线程间共享</li>
</ul>
</li>
</ul>
<pre><code class="c#">class Program
{
    
    static void Main(string[] args)
    {
        /*本地变量不共享*/
        //打印六次hello...
        Thread thread = new Thread(GO);
        thread.Start();
        GO();
        /*同一实例共享*/
        //打印一次Done！
        ThreadTest test = new ThreadTest();
        new Thread(test.Test).Start();
        Thread.Sleep(1000);
        test.Test();
        /*匿名委托共享*/
        //打印一次Done
        bool done = false;
        ThreadStart action = () =&gt;
            {
                if (!done)
                {
                    //此处还是会有输出多次的风险
                    done = true;
                    System.Console.WriteLine("Done");
                }
            };
        new Thread(action).Start();
        Thread.Sleep(new TimeSpan(0, 0, 1));
        action.Invoke();
        /*静态字段共享*/
        //打印一次Done！
        ThreadTest test1 = new ThreadTest();
        ThreadTest test2 = new ThreadTest();
        new Thread(test1.AnotherTest).Start();
        Thread.Sleep(10);
        test2.AnotherTest();
    }

    static void GO()
    {   
        //cycle是本地变量，属于本地状态
        //在每个线程的内存栈上，都会创建cycle的 独立副本
        for (int cycle = 0;  cycle&lt; 3; cycle++)
        {
            System.Console.WriteLine("hello...");
        }
    }

}

class ThreadTest
{
    private bool _done;
    private static bool done;
    public void AnotherTest()
    {
        //此处还是会有输出多次的风险
        if(!done)
        {
            System.Console.WriteLine("DONE!");
            done = true;
        }
    }
    public void Test()
    {
        //此处还是会有输出多次的风险
        if(!_done)
        {
            System.Console.WriteLine("Done!");
            _done = true;
        }
    }

}
</code></pre>
<ul>
<li>线程安全<ul>
<li>上述后涉及线程共享数据的代码是缺乏线程安全的，其实际输出无法确定，理论上Done有可能会打印两次，因为一个线程可能正在评估if，而另一个语句没来得及调整<code>done</code>为<code>true</code></li>
<li>保证线程安全：消除代码执行过程中的不确定性<ol>
<li>尽可能的避免使用共享状态以保证线程安全</li>
<li>使用<code>lock</code>语句加锁，在读取和写入共享数据的时候，通过使用互斥锁，就可以修复前面代码中的问题，当两个线程同时竞争一个锁的时候（锁可以基于任何引用类型对象），一个线程会等待或阻塞，直到锁重新变成可用状态</li>
</ol>
</li>
<li>然而，lock也并非线程安全的银弹，lock也会引起一些其他问题（如死锁）</li>
</ul>
</li>
</ul>
<pre><code class="c#">    class Program
    {
        static readonly object locker=new object();
        static bool done;
        static void Main(string[] args)
        {
            new Thread(GO).Start();
            GO();
        }

        static void GO()
        {
            // 锁要基于引用类型的变量
            // 线程安全
            lock(locker)
            {
                if (!done)
                {
                    System.Console.WriteLine("Done");
                    Thread.Sleep(1000);
                    done = true;
                }
            }
        }
    }
</code></pre>
<h3 id="Transfer-Parameter"><a href="#Transfer-Parameter" class="headerlink" title="Transfer Parameter"></a><strong>Transfer Parameter</strong></h3><ul>
<li>如果想往线程启动方法里传递参数，最简单的方式就是使用lambda表达式，在里面使用参数调用方法</li>
</ul>
<pre><code class="c#">class Program
    {
        
        static void Main(string[] args)
        {
            new Thread(() =&gt; { Print("hello world"); }).Start();

        }

        static void Print(string s)
        {
            System.Console.WriteLine(s);
        }
    }
</code></pre>
<ul>
<li>还可以使用<code>Thread.Start</code>方法来传递参数，类似委托中<code>Invoke</code>时的传参<ul>
<li>Thread的重载构造函数可以接受下列两个委托之一作为参数：<ol>
<li><code>public delegate void ThreadStart();</code></li>
<li><code>public delegate void ParameterizedThreadStart(object obj);</code></li>
</ol>
</li>
<li>第二种委托接收带参数的方法名</li>
</ul>
</li>
</ul>
<pre><code class="c#">class Program
{
    
    static void Main(string[] args)
    {
        Thread thread = new Thread(Print);
        thread.Start("hello world");
    }

    static void Print(object s)
    {
        s = s as string;
        System.Console.WriteLine(s);
    }
}
</code></pre>
<ul>
<li>需要注意的是lambda表达式（匿名委托）传的参数会当作字段，即就算传的是值类型的变量也会得到其地址并被线程共享；而第二种传参强制要求了引用变量，也会被线程共享</li>
</ul>
<pre><code class="c#">class Program
{  
    static void Main(string[] args)
    {
        // Thread1();
        Thread2();
    }

    // 线程共享了同一个局部变量i
    // 会出现重复的数
    static void Thread1()
    {
        for (int i = 0; i &lt; 5; i++)
        {
            new Thread(() =&gt; { System.Console.WriteLine(i); }).Start();
        }
    }
    // 每个线程获得不同局部变量的地址
    // 不会出现重复的数
    static void Thread2()
    {

        for (int i = 0; i &lt; 5; i++)
        {
            int temp = i;
            new Thread(() =&gt; { System.Console.WriteLine(temp); }).Start();
        }
    }
    
}
</code></pre>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a><strong>Exception</strong></h3><ul>
<li>异常处理块种的线程抛出异常时，不会被捕获，解决方案是传入线程的方法中处理异常</li>
</ul>
<pre><code class="c#">class Program
{  
    static void Main(string[] args)
    {
        // 正常捕获
        new Thread(Go2).Start();
        // 无法捕获
        try
        {
            new Thread(Go1).Start();
        }
        catch
        {
            System.Console.WriteLine("Exceptoin!");
        }
    }   

    static void Go1()
    {
        throw new Exception();
    }

    static void Go2()
    {
        try
        {
            throw new Exception();
        }

        catch
        {
            System.Console.WriteLine("catch sucessfully");
        }
    }
    
}
</code></pre>
<h3 id="Foreground-Threads-and-Background-Threads"><a href="#Foreground-Threads-and-Background-Threads" class="headerlink" title="Foreground Threads and Background Threads"></a><strong>Foreground Threads and Background Threads</strong></h3><ul>
<li>默认情况下，手动创建的线程就是前台线程</li>
<li>只要有前台线程在运行，那么应用程序就会一直处于活动状态<ul>
<li>后台线程运行不会保持应用程序的活动状态</li>
<li>一旦所有前台线程停止，应用程序随即停止，后台线程也会立即终止</li>
</ul>
</li>
<li>线程的前台、后台与它的优先级无关</li>
<li>通过<code>IsBackground</code>属性判断线程是否是后台线程</li>
</ul>
<pre><code class="c#">class Program
{  
    static void Main(string[] args)
    {
        Thread thread = new Thread(() =&gt; { Console.WriteLine(Console.ReadLine());});
        
        // 如果将thread设置为后台线程，当主线程（前台线程）执行完之后程序立即结束
        if(args.Length&gt;0)
            thread.IsBackground = true;

        thread.Start();
    }   
    
}
</code></pre>
<ul>
<li>如果在退出前想要等待后台线程执行完毕，可以考虑使用<code>Join</code></li>
<li>应用程序无法正常退出的一个常见原因就是还有活跃的前台线程</li>
</ul>
<h3 id="Priority-of-Threading"><a href="#Priority-of-Threading" class="headerlink" title="Priority of Threading"></a><strong>Priority of Threading</strong></h3><ul>
<li>线程的优先级（<code>Thread</code>中<code>Priority</code>属性）决定了相对于操作系统中其他活跃线程所占的执行时间</li>
<li>优先级划分：<ul>
<li><code>enum ThreadPriority{Lowest,BelowNormal,Normal,AboveNormal,Highest}</code></li>
</ul>
</li>
<li>提升线程优先级：<ul>
<li>提升线程优先级时要特别注意，因为他可能饿死其他线程</li>
<li>如果想让某线程的优先级比其他进程中的线程优先级高，那么就必须提升进程优先级</li>
</ul>
</li>
<li>手动提升进程/线程优先级适用于只做少量工作且需要较低延迟的非UI进程</li>
<li>对于需要大量计算的应用程序（尤其是带UI的），手动提升进程/线程优先级可能会使其他进程/线程饿死，从而降低整个计算机的速度</li>
</ul>
<h3 id="Signaling"><a href="#Signaling" class="headerlink" title="Signaling"></a><strong>Signaling</strong></h3><ul>
<li>某个线程在收到其他线程发来通知之前一直处于等待状态，发送通知的过程就称为Signaling，不同于信号量机制</li>
<li>最简单的信号结构就是<code>ManualResetEvent</code><ul>
<li>调用其上<code>WaitOne</code>方法会阻塞当前线程，直到另一个线程通过调用<code>Set</code>方法开启信号</li>
</ul>
</li>
</ul>
<pre><code class="c#">class Program
{ 
    static void Main(string[] args)
    {
        var signal = new ManualResetEvent(false);

        new Thread(() =&gt;
        {
            System.Console.WriteLine("Waiting for signal...");
            // 因为在实例化时设置了false主线程打开信号之前处于阻塞状态
            // 成功接收到信号时不会将signal状态重置为nonusignaled
            signal.WaitOne();
            // 获得信号后直接关闭该信号量
            System.Console.WriteLine("Got signal!");
        }).Start();
        for (int i = 0; i &lt; 5; i++)
        {
            System.Console.WriteLine(i);
        }
        Thread.Sleep(1000);
        signal.Set();
    }   
}
</code></pre>
<ul>
<li>调用完<code>Set</code>后信号会处于signaled状态，通过调用<code>Reset</code>将信号重新变为nonsignaled状态</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/11/22/CSAsync3/" title="C# Asynchronous programming #3"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: C# Asynchronous programming #3</span></a><a class="button is-default" href="/2021/11/22/CSAsync1/" title="C# Asynchronous programming #1"><span class="has-text-weight-semibold">Next: C# Asynchronous programming #1</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiaoyu2018/xiaoyu2018.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/xiaoyu2018"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Xavier 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>