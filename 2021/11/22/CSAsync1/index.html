<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>C# Asynchronous programming #1</title><meta name="description" content="while(true) me.Learn();"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/tom.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
C# Asynchronous programming #1Thread
What is Thread ?
线程是一个可执行路径，每一个线程可以独立于其他线程执行
每个线程在均进程(Process)内执行，在操作系统中，进行提供了程序运行的独立环境
单线程应用，在进程的独立环境中只跑一个线程，该线程具有独占权
多线程应用，单个进程中跑多个线程，多个线程共享当前的执行环境（尤其是内存）
共享：多个线程共同占有某种资源，如一个线程在后台读取数据，另一个线程在数据到达后进行展示。  



下面是c#中最简单的异步编程实例：
class Program
{
    static void Main(string[] args)
    {
        Thread.CurrentThread.Name = .."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Xavier's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Xavier's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">C# Asynchronous programming #1</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-Asynchronous-programming-1"><span class="toc-text">C# Asynchronous programming #1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread"><span class="toc-text">Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-Thread"><span class="toc-text">What is Thread ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-and-Sleep"><span class="toc-text">Join and Sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blocking"><span class="toc-text">Blocking</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Asynchronous-programming"><i class="tag post-item-tag">Asynchronous-programming</i></a><a href="/tags/CS-Threading"><i class="tag post-item-tag">CS-Threading</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">C# Asynchronous programming #1</h1><time class="has-text-grey" datetime="2021-11-22T08:35:34.837Z">2021-11-22</time><article class="mt-2 post-content"><p><img src="/images/CSAsynchronousProgramming/cover.png" alt="$cover"></p>
<h1 id="C-Asynchronous-programming-1"><a href="#C-Asynchronous-programming-1" class="headerlink" title="C# Asynchronous programming #1"></a>C# Asynchronous programming #1</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><strong>Thread</strong></h2><hr>
<h3 id="What-is-Thread"><a href="#What-is-Thread" class="headerlink" title="What is Thread ?"></a><strong>What is Thread ?</strong></h3><ul>
<li>线程是一个可执行路径，每一个线程可以独立于其他线程执行</li>
<li>每个线程在均进程(Process)内执行，在操作系统中，进行提供了程序运行的独立环境</li>
<li>单线程应用，在进程的独立环境中只跑一个线程，该线程具有独占权</li>
<li>多线程应用，单个进程中跑多个线程，多个线程共享当前的执行环境（尤其是内存）<ul>
<li>共享：多个线程共同占有某种资源，如一个线程在后台读取数据，另一个线程在数据到达后进行展示。  </li>
</ul>
</li>
</ul>
<p>下面是c#中最简单的异步编程实例：</p>
<pre><code class="c#">class Program
{
    static void Main(string[] args)
    {
        Thread.CurrentThread.Name = "Main Thread...";
        //开辟一个新线程            
        Thread thread = new Thread(WriteY);
        thread.Name = "Y Thread...";
        thread.Start();
        Thread.Sleep(1);
        //同时在主线程上做一些工作
        System.Console.WriteLine(Thread.CurrentThread.Name);
        for (int i = 0; i &lt; 1000; i++)
        {
            System.Console.Write("x");
        }
        

    }

    static void WriteY()
    {
        System.Console.WriteLine(Thread.CurrentThread.Name);
        for (int i = 0; i &lt; 1000; i++)
        {
            System.Console.Write("y");
        }
        
    }
}
</code></pre>
<ul>
<li>在单核计算机上，操作系统必须为每个线程分配<strong>时间片</strong>（Windows下通常为20ms）来模拟并发，从而在本例中，会输出重复的x块与y块</li>
<li>在多核或多处理器的计算机上，使用c#创建的多线程可以真正意义上并行执行。然而，在本例中由于控制台程序处理并发请求机制的微妙性，仍然会得到重复的x块与y块<br><img src="/images/CSAsynchronousProgramming/first_example.png" alt="first_example"></li>
<li>c#中线程的一些属性：<ul>
<li>线程一旦开始执行，属性<code>IsAlive</code>就变为<code>true</code>，线程结束就变为<code>false</code></li>
<li>线程结束的条件：线程构造器中传入的委托结束了执行</li>
<li>线程一旦结束，便无法重启</li>
<li>每个线程都有一个<code>Name</code>属性，通常用于调试，<code>Name</code>只能设置一次，多次更改会抛出异常</li>
<li>静态属性<code>Thread.CurrentThread</code>，指向当前执行的线程</li>
</ul>
</li>
</ul>
<h3 id="Join-and-Sleep"><a href="#Join-and-Sleep" class="headerlink" title="Join and Sleep"></a><strong>Join and Sleep</strong></h3><ul>
<li>在线程A中调用另一个线程B实例的<code>Join</code>方法，线程A便会等待线程B执行结束后继续执行。</li>
<li>调用<code>Jion</code>方法时，可在参数中设置一个超时(毫秒/<code>TimeSpan</code>)<ul>
<li>使用有超时的重载方法时返回值<code>bool</code>类型，<code>true</code>：线程结束；<code>false</code>：超时</li>
</ul>
</li>
<li><code>Thread.Sleep</code>方法会暂停当前的线程，并等待一段时间<ul>
<li><code>Thread.Sleep(0)</code>会导致县城立即放弃本身当前时间片，自动将cpu转交给其他线程</li>
<li><code>Thread.Yield</code>与<code>Thread.Sleep</code>做同样的事情，不同的是<code>Thread.Yield</code>只会把执行交给同一处理器的其他线程</li>
<li>当等待<code>Sleep</code>和<code>Join</code>时，线程处于阻塞状态</li>
</ul>
</li>
</ul>
<pre><code class="c#">class Program
    {
        static Thread thread1;
        static Thread thread2;
        static void Main(string[] args)
        {
            thread1 = new Thread(ThreadProc);
            thread1.Name = "t1";
            thread1.Start();

            thread2 = new Thread(ThreadProc);
            thread2.Name = "t2";
            thread2.Start();
        }


        private static void ThreadProc()
        {
            System.Console.WriteLine($"\nCurrent thread:{Thread.CurrentThread.Name}");
            if(Thread.CurrentThread.Name=="t1"&amp;&amp;
            ((thread2.ThreadState&amp;ThreadState.Unstarted)==0))
                if(thread2.Join(2000))
                    System.Console.WriteLine("t2 has been terminated");
                else
                    System.Console.WriteLine("overtime");

            //TimeSpan(0,0,4) 0h，0m，4s
            Thread.Sleep(new TimeSpan(0,0,4));
            System.Console.WriteLine($"\nCurrent thread:{Thread.CurrentThread.Name}");
            System.Console.WriteLine($"Thread1:{thread1.ThreadState}");
            System.Console.WriteLine($"Thread2:{thread2.ThreadState}");

        }
    }
</code></pre>
<p>在一次执行中，输出结果如下：<br><img src="/images/CSAsynchronousProgramming/join_sleep.png" alt="join_sleep"><br>在此次运行过程中，线程<code>t2</code>首先进入<code>ThreadProc</code>，之后开始Sleep，时间片交给线程<code>t1</code>，if判断成立，<code>t1</code>进入阻塞状态等待<code>t2</code>运行结束。<code>t2</code>Sleep结束后开始运行，运行结束后，<code>t1</code>继续运行直到结束</p>
<h3 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a><strong>Blocking</strong></h3><ul>
<li>如果线程的执行由于某种原因导致暂停，那么就认为该线程被阻塞了<ul>
<li>如<code>Sleep</code>、<code>Join</code></li>
</ul>
</li>
<li>被阻塞的线程会立即将其时间片交给其他线程，从此不再消耗处理器时间，知道满足阻塞结束条件为止</li>
<li>可以通过<code>ThreadState</code>属性来判断线程是否处于阻塞状态</li>
<li><code>ThreadState</code>是一个<em>flags enum</em>，通过按位与/或来合并数据项<br><img src="/images/CSAsynchronousProgramming/thread_state.png" alt="thread_state"><br><code>ThreadState</code>变化图如下：<br><img src="/images/CSAsynchronousProgramming/transform.png" alt="transform"><br>常用的状态只有四个：<code>Unstarted</code>、<code>Running</code>、<code>WaitSleepJoin</code>和<code>Stopped</code></li>
</ul>
<pre><code class="c#">  public static ThreadState Foo(ThreadState ts)
          {
              return ts &amp; (
                  ThreadState.Stopped |
                  ThreadState.Unstarted |
                  ThreadState.WaitSleepJoin
              );
          }
</code></pre>
<ul>
<li><p>当遇到下列四种情况解除阻塞：</p>
<ul>
<li>阻塞条件被满足</li>
<li>操作超时(如果设置了超时)</li>
<li>通过<code>Thread.Interrupt()</code>进行打断</li>
<li>通过<code>Thread.Abort()</code>进行中止</li>
</ul>
</li>
<li><p>上下文切换</p>
<ul>
<li>当线程阻塞或解除阻塞时，操作系统执行上下文切换。这会产生少量开销，通常为1或2微秒</li>
</ul>
</li>
<li><p>I/O密集型与CPU密集型</p>
<ul>
<li>花费大部分时间等待某事发生的操作称为I/O密集型，通常此事指输入/输出，但不是硬性要求，如<code>Thread.Sleep()</code>被视为I/O密集型</li>
<li>相反，一个花费大部分时间执行CPU密集型的操作成为CPU密集型</li>
</ul>
</li>
<li><p>阻塞与忙等待</p>
<ul>
<li>阻塞是在当前线程上同步的等待，<code>Console.ReadLine()</code>、<code>Thread.Sleep()</code>、<code>Thread.Join()</code>都是阻塞操作</li>
<li>忙等待以周期性的在一个循环里打转，也是同步的<br><code>while(DataTime.Now&lt;nextStartTime)</code></li>
<li>还有一种异步的操作，在操作完成后触发回调</li>
<li>如果条件很快得到满足（在几微秒之内）,短暂的忙等待更为适合，因为他避免了上下文切换的开销</li>
</ul>
</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/11/22/CSAsync2/" title="C# Asynchronous programming #2"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: C# Asynchronous programming #2</span></a><a class="button is-default" href="/2021/11/22/d2l_1/" title="D2L: Matrix"><span class="has-text-weight-semibold">Next: D2L: Matrix</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiaoyu2018/xiaoyu2018.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/xiaoyu2018"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Xavier 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>