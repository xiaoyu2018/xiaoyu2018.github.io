<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xavier&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-20T13:11:59.281Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Xavier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Index</title>
    <link href="http://example.com/2023/02/20/mysql_9/"/>
    <id>http://example.com/2023/02/20/mysql_9/</id>
    <published>2023-02-20T13:11:59.281Z</published>
    <updated>2023-02-20T13:11:59.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><blockquote><p>索引建立在表上。</p></blockquote><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a><strong>MySQL索引</strong></h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul><li>索引是MySQL中用于高效获取数据的数据结构。通俗的说，数据库索引好比是一本书的目录，可以直接根据页码找到对应的内容，目的就是为了加快数据库的查询速度</li><li>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</li><li>一种能帮助mysql提高了查询效率的数据结构：索引数据结构</li></ul><h3 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h3><ul><li>一句话总结：以空间换时间</li><li>未添加索引的数据库，在查询时按全文进行搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕，这样的效率很低，也体现了在大数据中索引的必要性</li><li>索引本身也很大而且也有持久化存储的需求，所以其存储在硬盘文件中，一般是单独的索引文件或和数据一起存储在数据文件</li></ul><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>主键索引：设定主键后，数据库自动建立索引，InnoDB中为聚簇索引，主键索引列值不能为空（Null）</li><li>普通索引：又称单值索引，即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：指定某一列进行索引，列中的值必须唯一，允许有空值（Null），但只允许有一个空值（Null）</li><li>复合索引：又称组合索引、联合索引。一个索引可以包含多个列，多个列共同构成一个复合索引</li><li>全文索引：MySQL5.7之前，只有MYISAM存储引擎引擎支持全文索引，全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找允许在这些索引列中插入重复值和空值。全文索引可以在Char、VarChar 上创建</li><li>前缀索引：在文本类型为char、varchar、text类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定</li></ul><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><ul><li>优点：<ul><li>提高数据查询速度</li><li>降低数据库I/O成本，为建立索引前需要将记录逐条读入内存比较后加入结果集</li><li>被索引的列会自动排序，提高需要排序的场景的性能</li></ul></li><li>缺点：<ul><li>索引额外占用磁盘空间</li><li>索引虽然提升查询效率，但降低更新效率，因为每次更新表数据时要同时更新索引</li><li>维护索引要消耗数据库资源</li></ul></li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p>创建索引</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 主键索引</span><br><span class="hljs-comment">-- 建表时指定主键，自动以主键建立索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段<span class="hljs-number">1</span> 类型 <span class="hljs-keyword">primary</span> key,<br>字段<span class="hljs-number">2</span> 类型,<br>字段<span class="hljs-number">3</span> 类型<br>);<br><br><span class="hljs-comment">-- 普通索引</span><br><span class="hljs-keyword">CREATE</span> INDEX 索引名 <span class="hljs-keyword">ON</span> 表名(字段名)<br><br><span class="hljs-comment">-- 唯一索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX 索引名 <span class="hljs-keyword">ON</span> 表名(字段名)<br><br><span class="hljs-comment">-- 复合索引</span><br><span class="hljs-keyword">CREATE</span> INDEX 索引名 <span class="hljs-keyword">ON</span> 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ...)<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>查看索引</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> INDEX <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除索引</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX 索引名 <span class="hljs-keyword">ON</span> 表名;<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a><strong>索引的数据结构</strong></h2><p>MySQL索引使用的数据结构主要有BTree索引和hash索引。</p><h3 id="不同存储引擎对索引有不同的实现方式"><a href="#不同存储引擎对索引有不同的实现方式" class="headerlink" title="不同存储引擎对索引有不同的实现方式"></a>不同存储引擎对索引有不同的实现方式</h3><ul><li>MyISAM：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则根据data域中磁盘地址到磁盘中寻址定位到对应的磁盘块，然后读取相应的数据记录，这被称为“非聚簇索引”</li><li>InnoDB：其数据文件本身就是索引文件。相比MyISAM的索引文件数据文件分离，其表数据文件本身就是按照B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的Key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方</li></ul><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>Hash表，以键值对的形式存储数据。使用hash表存储表数据结构时，Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时只能通过扫描全表的方式，筛选出符合条件的数据。</p><p>显然这种方式，不适合我们经常需要查找和范围查找的数据库索引使用。</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><ul><li><p>平衡二叉树</p><ul><li>平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。</li><li>使用平衡二叉查找树查询的性能接近与二分查找，时间复杂度为O(log2n)</li><li>然而平衡二叉树依旧存在一些问题：<ul><li>时间复杂度和树的高度有关。树有多高就需要I/O多少次（MySQL每次只将一个索引树节点读入内存）</li><li>平衡二叉树不支持范围查询快速查找，范围查询需要从根节点多次遍历，查询效率不高</li></ul></li></ul></li><li><p>B树<br><img src="/images/mysql/6.png"></p><ul><li>B树是多叉平衡查找树，他将索引由高瘦变成矮胖，从而大大减少了检索时的I/O次数</li><li>特点：<ul><li>B树的节点中存储这多个元素，每个内节点有多个分叉</li><li>节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点中都存储数据</li><li>父节点当中的元素不会出现在子节点中</li><li>所有的叶子节点都位于同一层，叶子节点具有相同的深度，叶子节点之间没有指针连接</li></ul></li><li>缺陷：<ul><li>不支持快速范围查找，如根据上图，想查询10到35之间的数据查询到10后需要回到根节点再重新多次遍历</li><li>每个节点都保存数据或数据的地址，如果节点中data块保存的是数据那么data块就会随着表中字段的增加而变大，这样节点占用的空间就要变大，又由于MySQL单此I/O具有上限，单个节点保存的索引数就要降低，就会使B树重新变得瘦高，降低了性能</li></ul></li></ul></li><li><p>B+树<br><img src="/images/mysql/6.png"></p><ul><li>B+树，作为B树的升级版，和B树最主要的区别在于B+树只在叶子节点存储数据或数据的地址，B+树也是MySQL使用的索引数据结构之一</li><li>B+树的非叶子节点只存储键和指针，叶子节点存储键和数据，并且在叶子节点之间使用双向指针相连，形成了一个<strong>双向有序链表</strong></li><li>B+树的最底层叶子节点包含了所有的索引项。从上图可以看出，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在查询数据的情况下每次的磁盘IO次数跟树的高度有直接的关系；但是从另一方面来说，由于数据都被存放到了叶子节点，所以存放索引的磁盘块，所存放的的索引数量会随之增加，所以相对于B树来说，B+树的树高理论情况下是比B树树高要矮的。</li><li>B+树的范围查询也有更好的性能，由于叶子节点组成了双向有序链表，所以只需查找到范围两端对应的叶子节点即可找到整个范围包含的所有记录</li></ul></li></ul><h2 id="MySQL的索引实现"><a href="#MySQL的索引实现" class="headerlink" title="MySQL的索引实现"></a><strong>MySQL的索引实现</strong></h2><p>不同存储引擎实现索引的方式不同。下面分别对两个引擎举例说明MySQL索引实现过程</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>以一个简单的user表为例，user表存在两个索引，id列为主键索引，age列为普通索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>`<br>(<br>  `id`       <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age`      <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)     <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE,<br>  KEY `idx_age` (`age`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> MyISAM<br>  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br></code></pre></td></tr></tbody></table></figure><p>MyISAM的数据文件和索引文件是分开存储的，MyISAM使用B+树构建索引树时，叶子节点中键值key存储的是索引列的值，数据data存储的是索引所在行的磁盘地址。</p><h4 id="根据主键等值查询数据"><a href="#根据主键等值查询数据" class="headerlink" title="根据主键等值查询数据"></a>根据主键等值查询数据</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">28</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/images/mysql/8.png"></p><h4 id="根据主键范围查询数据"><a href="#根据主键范围查询数据" class="headerlink" title="根据主键范围查询数据"></a>根据主键范围查询数据</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-number">28</span><span class="hljs-operator">&lt;=</span>id<span class="hljs-operator">&lt;=</span><span class="hljs-number">47</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="/images/mysql/8.png"></p><h4 id="根据辅助索引查找"><a href="#根据辅助索引查找" class="headerlink" title="根据辅助索引查找"></a>根据辅助索引查找</h4><p>在MyIASM中，辅助索引建立起一个以age为索引的新B+树，其他过程与主键索引基本相同，只有一点需要注意MyIASM的辅助索引键可能不唯一，可能存在多个拥有相同键的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树种检索数据</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB在建表时默认就会根据主键建立索引，并且在索引树中直接存储记录数据（成为聚簇索引），而非像MyIASM一样只存储记录数据的地址。</p><p>每个InnoDB表都有一个聚簇索引，聚簇索引使用B+树构建，叶子节点的data阈存储的是整行记录。具体创建规则如下：</p><ol><li>InnoDB创建索引的具体规则如下：</li><li>如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。</li><li> 如果以上两个都没有，InnoDB会自动使用一个长度为6字节的ROWID字段来构建聚簇索引，该ROWID字段会在插入新的行记录时自动递增。</li></ol><p>除聚簇索引之外的所有索引都被称为辅助索引。在InnoDB中，辅助索引中的叶子节点键值存储的是该行的主键值。在检索时，InnoDB最终还是要使用主键在聚簇索引中搜索行记录，这个过程称之为回表。</p><p>以user_innodb表为例，user_innodb的id列为主键，age列为普通索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `user_innodb`<br>(<br>  `id`       <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age`      <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)     <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE,<br>  KEY `idx_age` (`age`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB;<br></code></pre></td></tr></tbody></table></figure><h4 id="主键索引（聚簇索引）"><a href="#主键索引（聚簇索引）" class="headerlink" title="主键索引（聚簇索引）"></a>主键索引（聚簇索引）</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">28</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="/images/mysql/9.png"></p><h4 id="单值辅助索引"><a href="#单值辅助索引" class="headerlink" title="单值辅助索引"></a>单值辅助索引</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user_innodb <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="/images/mysql/10.png"><br>磁盘IO数（从根节点开始）：辅助索引3次 + 回表过程3次。</p><h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><p>以表中多个字段组合形成索引的key，也是一种辅助索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> abc_innodb <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">13</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">16</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="/images/mysql/11.png"></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引并不是一种索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到相应的主键值，想要获取最终的数据记录，还需要根据主键通过主键索引再去检索，最终获取到符合条件的数据记录。而如果我们使用的是组合索引，而要查询的值恰好包含在组合索引的key中，则不需要回表查询操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;索引建立在表上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;MySQL索引&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Database Designment</title>
    <link href="http://example.com/2023/02/18/mysql_7/"/>
    <id>http://example.com/2023/02/18/mysql_7/</id>
    <published>2023-02-18T07:55:39.246Z</published>
    <updated>2023-02-18T07:55:39.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Database-Designment"><a href="#Database-Designment" class="headerlink" title="Database Designment"></a>Database Designment</h1><p>数据库设计是指对于一个给定的应用场景，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库，满足各种用户的应用需求。<br>一般的设计步骤为：  </p><ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行维护</li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h2><p>通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）工作概况，明确用户的各种需求。<br>其任务是由数据库设计人员和用户双方共同收集信息需求和处理需求；通过仔细分析；将这些需求按一定的规范要求以用户和设计人员都能理解接受的文档形式确定下来。</p><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a><strong>概念结构设计</strong></h2><p>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型。<br>最常用的概念模型即E-R模型。<br>E-R模型将现实世界中的信息用实体、属性和实体之间的联系表示。<br>一些E-R图的要点如下：</p><ul><li>矩形表示实体、椭圆表示属性、零星表示关系</li><li>关系是实体间的关系，有三种：1对1、1对n、m对n</li><li>属性必须为不可再分的项，不能包含其他属性，不能与其他实体具有关系</li></ul><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a><strong>逻辑结构设计</strong></h2><p>将概念结构转换成特定DBMS所支持的数据模型的过程。MySQL是关系型数据库，所以此步便是将E-R图转换为表的过程。<br>在此阶段，要做的事一般包括以下三点：</p><ul><li>将概念模型(E-R图)转换为关系模式（表）的集合</li><li>使用范式理论对模式进行优化</li><li>设计关系子模式–视图</li></ul><h3 id="E-R图向关系模型（表）的转换"><a href="#E-R图向关系模型（表）的转换" class="headerlink" title="E-R图向关系模型（表）的转换"></a>E-R图向关系模型（表）的转换</h3><ul><li>一个实体对应一个表，联系也可以单独对应一个表，实体或联系的属性构成表的字段</li><li>1:1联系中，可以将联系单独建表（包含字段为联系两端实体的主键+联系本身的属性）;也可以将联系归入任一一端实体（为这个实体对应的表增加字段另一个实体的主键和原来联系包含的属性）</li><li>1:n联系中，可以将联系单独建表（包含字段为联系两端实体的主键+联系本身的属性）;也可以将联系归入任n端实体（为这个实体对应的表增加字段另一个实体的主键和原来联系包含的属性）</li><li>m:n联系中，只能将联系单独建表（包含字段为联系两端实体的主键+联系本身的属性）</li><li>多实体联系中，只能将联系单独建表（包含字段为联系多端实体的主键+联系本身的属性）</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>为了建立<strong>冗余较小</strong>、<strong>结构合理</strong>的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。<br>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。<br>数据库的范式设计得越高阶，冗余度就越低，同时高阶的范式一定满足低阶的范式的要求。一般来说，在关系型数据库中，最高也就遵循到BCNF，普遍是3NF，但也不是绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p><ul><li><p>1NF：第一范式要求确保数据表中每个字段的值都具有原子性，也就是说表中每个字段不能再被拆分。这个范式一定需要遵守。</p></li><li><p>2NF：在满足第一范式的基础上，还要满足数据库表中的每一条数据，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</p><ul><li>比赛表（球员编号，比赛编号）–&gt; (姓名，年龄，比赛时间，场地，得分)则不满足第二范式。虽然联合主键（球员编号，比赛编号）可以唯一标识么一条记录，但比赛表存在部分依赖，即（球员编号）–&gt; (姓名，年龄)和(比赛编号–&gt;比赛时间，比赛场地)</li><li>不满足第二范式会产生如下问题：<ul><li>数据冗余：如果一个球员参加了n场比赛，那么球员的姓名和年龄就重复了n次，一个比赛也有可能有m个球员参加，那比赛的时间和地点就重复了m次。</li><li>插入异常：如果我们想要添加一场新的比赛，但是这时球员还没有确定，那么就无法插入。</li><li>删除异常：如果我们想要删除某个球员编号，会将比赛信息删除掉。</li><li>更新异常：如果我们想要调整某个比赛的时间，那么数据库表中所有关于这个比赛的时间都需要进行调整，否则会出现一场比赛时间不同的情况。</li></ul></li><li>将比赛表调整为球员表（球员编号，姓名，年龄）、比赛表（比赛编号，比赛场地，比赛时间）和得分表（比赛编号，球员编号，得分）三个表则满足2NF</li></ul></li><li><p>3NF：在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段字段。（即不能存在非主属性A依赖非主属性B，非主属性B依赖于主键C的情况）。通俗来说，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p><ul><li>员工信息表（员工编号）–&gt;(姓名，部门编号，部门名称)满足2NF，但是存在(部门编号)–&gt;(部门名称)不满足3NF</li><li>将其分为员工表（员工编号，姓名）和部门表（部门编号，部门名称）满足3NF</li></ul></li><li><p>BCNF：前三个范式消除了非主属性对候选键的部分依赖和传递依赖，如果进一步消除主属性对候选键的部份依赖和传递依赖则满足BCNF</p><ul><li>仓库表（仓库名，管理员，物品名，数量）有仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量。其候选键为：（管理员，物品名），（仓库名，物品名）。主属性为：仓库名、管理员、物品名</li><li>满足3NF，但由于主属性管理员部分依赖于候选键(仓库名，物品名)不满足BCNF</li><li>将其拆分为仓库（仓库名，管理员）、库存（仓库名，物品名，数量）满足BCNF</li></ul></li></ul><h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a><strong>物理结构设计</strong></h2><p>为逻辑数据结构选取一个最适合应用环境的物理结构,包括存储结构和存取方法。<br>此阶段的工作是：</p><ul><li>为关系模式选取合适的存取方法（即索引）</li><li>设计关系(表)、聚簇、索引、日志、备份等数据的物理存储结构及确定系统配置<ul><li>可以将比较大的表分别放在两个磁盘上，以加快存取速度，这在多用户环境下特别有效</li><li>可以将日志文件与数据库对象（表、索引等）放在不同的磁盘以改进系统的性能</li><li>系统都为数据库的系统配置（同时使用数据库的用户数、同时打开的数据库对象数、内存分配参数、缓冲区分配参数（使用的缓冲区长度、个数）、存储分配参数 、物理块的大小、物理块装填因子、时间片大小、数据库的大小、锁的数目等）赋予了合理的缺省值。在进行物理设计时需要根据应用环境确定这些参数值，以使系统性能最优。</li></ul></li></ul><h2 id="数据库实施"><a href="#数据库实施" class="headerlink" title="数据库实施"></a><strong>数据库实施</strong></h2><p>根据逻辑设计和物理设计的结果构建数据库,编写与调试应用程序,组织数据入库并进行试运行。<br>此阶段的工作是：</p><ul><li>建立数据库，建表</li><li>装入数据</li><li>测试运行</li></ul><h2 id="数据库运行和维护"><a href="#数据库运行和维护" class="headerlink" title="数据库运行和维护"></a><strong>数据库运行和维护</strong></h2><p>经过试运行后即可投入正式运行,在运行过程中必须不断对其进行评估、调整与修改。<br>此阶段的工作是：</p><ul><li>数据库备份和恢复</li><li>数据库权限控制</li><li>数据库性能监督、分析与改进</li><li>数据库重组织和重构造（数据库长期运行的dml操作会使物理存储性能变差，重组织可以提高系统性能）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Database-Designment&quot;&gt;&lt;a href=&quot;#Database-Designment&quot; class=&quot;headerlink&quot; title=&quot;Database Designment&quot;&gt;&lt;/a&gt;Database Designment&lt;/h1&gt;&lt;p&gt;数据</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Transaction</title>
    <link href="http://example.com/2023/02/18/mysql_10/"/>
    <id>http://example.com/2023/02/18/mysql_10/</id>
    <published>2023-02-18T06:56:05.557Z</published>
    <updated>2023-02-18T06:56:05.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Transaction&quot;&gt;&lt;a href=&quot;#Transaction&quot; class=&quot;headerlink&quot; title=&quot;Transaction&quot;&gt;&lt;/a&gt;Transaction&lt;/h1&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Stored Procedure &amp; Trigger</title>
    <link href="http://example.com/2023/02/18/mysql_8/"/>
    <id>http://example.com/2023/02/18/mysql_8/</id>
    <published>2023-02-18T06:54:24.685Z</published>
    <updated>2023-02-16T08:35:50.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stored-Procedure-amp-Trigger"><a href="#Stored-Procedure-amp-Trigger" class="headerlink" title="Stored Procedure &amp; Trigger"></a>Stored Procedure &amp; Trigger</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h2><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>封装编译的sql语句，能隐藏复杂的商业逻辑</li><li>可以被外部程序直接调用，接受参数并返回值</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>存储过程不可被select指令运行</li><li>存储过程往往定制化于特定的数据库上，对编程语言的接口没有达成同意规范。当切换到其他厂商的数据库系统时，一般需要重写原有的存储过程</li><li>存储过程的性能调校与撰写，受限于各种数据库系统</li><li>目前业界几乎不用存储过程，存储过程的功能完全可由编程语言代替</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h2><p>触发器是MySQL提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。  </p><blockquote><p>和编程语言中的事件机制思想相似。</p></blockquote><h3 id="触发器创建四要素"><a href="#触发器创建四要素" class="headerlink" title="触发器创建四要素"></a>触发器创建四要素</h3><ul><li>监视地点（table）</li><li>监视事件（insert/update/delete）</li><li>触发时间（after/before）</li><li>触发事件（insert/update/delete）</li></ul><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 触发器t1建立在表orders上</span><br><span class="hljs-comment">-- 在orders每次发生插入操作后被触发</span><br><span class="hljs-comment">-- 触发后执行`update goods set num=num-2 where gid = 1;`</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> t1 <br>after<br><span class="hljs-keyword">insert</span><br><span class="hljs-keyword">on</span> orders<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br> update goods <span class="hljs-keyword">set</span> num<span class="hljs-operator">=</span>num<span class="hljs-number">-2</span> <span class="hljs-keyword">where</span> gid <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span>$<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Stored-Procedure-amp-Trigger&quot;&gt;&lt;a href=&quot;#Stored-Procedure-amp-Trigger&quot; class=&quot;headerlink&quot; title=&quot;Stored Procedure &amp;amp; Trigger&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Basic SQL</title>
    <link href="http://example.com/2023/02/16/mysql_1/"/>
    <id>http://example.com/2023/02/16/mysql_1/</id>
    <published>2023-02-16T07:38:11.525Z</published>
    <updated>2023-02-16T07:38:11.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic-SQL"><a href="#Basic-SQL" class="headerlink" title="Basic SQL"></a>Basic SQL</h1><p>数据库语言可分为两个部分，DDL和DML。</p><ul><li>DDL（Data Definitoin Language）：描述数据库中要存储的现实世界实体（操作表），操作数据库的结构等</li><li>DML（Data Manipulation Language）：操作数据库存储的对象或记录</li><li>DQL（Data Query Language）：查询数据库中记录</li></ul><h2 id="SQL-DDL-数据定义"><a href="#SQL-DDL-数据定义" class="headerlink" title="SQL DDL:数据定义"></a><strong>SQL DDL:数据定义</strong></h2><h3 id="数据库命令"><a href="#数据库命令" class="headerlink" title="数据库命令"></a>数据库命令</h3><ul><li><p>查询数据库</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--显示当前mysql服务器中所有数据库</span><br><span class="hljs-keyword">SHOW</span> DATABASES;<br><span class="hljs-comment">--显示创建某一数据库时的语句</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> DATABASE 数据库名称;<br></code></pre></td></tr></tbody></table></figure></li><li><p>创建新数据库</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--字符集为utf-8(默认就是)，校验规则utf8_general_ci(不区分大小写，默认就是)</span><br><span class="hljs-comment">--创建数据库名称是使用反引号规避关键字</span><br><span class="hljs-comment">--数据库的字符集和校对规则会成为该数据库下表的默认规则</span><br><span class="hljs-comment">--utf8_bin区分大小写，大小写指的是数据库中记录的字符大小写 </span><br><span class="hljs-keyword">CREATE</span> DATABASE 数据库名称 <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集 <span class="hljs-keyword">COLLATE</span> 校验规则;<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除数据库</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE 数据库名称;<br></code></pre></td></tr></tbody></table></figure></li><li><p>备份和恢复数据库  </p><ul><li>备份数据库即将数据库导出至其他文件，恢复数据库即从备份文件恢复至某一DBMS，备份与恢复操作不是sql指令需要在shell执行，mysql提供的程序在mysql目录中的bin文件夹下，备份其实就是备份数据库生命周期内从头到尾对应的sql语句。</li><li>备份：<code>./mysqldump -u 用户名 -p -B 数据库1 数据库2 ... &gt; 备份文件的路径</code></li><li>恢复：直接用dbms终端打开备份sql文件并执行或者打开mysql命令行执行：<code>source 备份文件路径</code></li></ul></li></ul><h3 id="表命令"><a href="#表命令" class="headerlink" title="表命令"></a>表命令</h3><ul><li><p>查询表</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--显示当前数据库中全部表</span><br><span class="hljs-keyword">SHOW</span> TABLES;<br><span class="hljs-comment">--显示某一张表的信息</span><br><span class="hljs-keyword">DESC</span> 表名<br></code></pre></td></tr></tbody></table></figure></li><li><p>创建新表</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">   <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名<br>   (<br>字段名称<span class="hljs-number">1</span> 数据类型(容量) 约束，<br>字段名称<span class="hljs-number">2</span> 数据类型(容量) 约束，<br>字段名称<span class="hljs-number">3</span> 数据类型(容量) 约束,<br>...    <br>   )<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集 <span class="hljs-keyword">COLLATE</span> 校验规则 ENGINE 引擎;<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除表</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名称;<br></code></pre></td></tr></tbody></table></figure></li><li><p>修改表</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 添加列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br><span class="hljs-keyword">ADD</span> (<br>字段名 数据类型(容量) 约束,<br>字段名 数据类型(容量) 约束,<br>...<br>);<br><br>#修改列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>MODIFY 字段名 数据类型(容量) 约束;<br><br>#修改列名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>CHANGE 旧字段名 新字段名 数据类型(容量) 约束;<br><br>#删除列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br><span class="hljs-keyword">DROP</span> 字段名;<br><br># 修改表名<br>RENAME <span class="hljs-keyword">TABLE</span> 旧表名 <span class="hljs-keyword">TO</span> 新表名;<br></code></pre></td></tr></tbody></table></figure></li><li><p>备份及恢复表</p><ul><li>同样使用mysqldump,使用命令：<br><code>mysqldump -u 用户名 -p密码 数据库名 表1 表2... &gt; 备份文件路径</code></li><li>恢复表同恢复数据库的操作，要注意切换到目标数据库之后再执行备份语句</li></ul></li></ul><h2 id="SQL-DML-数据操作"><a href="#SQL-DML-数据操作" class="headerlink" title="SQL DML:数据操作"></a><strong>SQL DML:数据操作</strong></h2><ul><li><p>插入</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 向表中插入一条或多条记录</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <br>    (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ...) <br>    <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...)<br>           (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...)<br>           (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...)<br>        ...;<br></code></pre></td></tr></tbody></table></figure></li><li><p>修改</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改表中某一条记录</span><br>UPDATE <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> 字段<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>, ... <span class="hljs-keyword">WHERE</span> ...;<br><br><span class="hljs-comment">-- 在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</span><br>UPDATE <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> score<span class="hljs-operator">=</span>score<span class="hljs-operator">+</span><span class="hljs-number">10</span> <span class="hljs-keyword">WHERE</span> score<span class="hljs-operator">&lt;=</span><span class="hljs-number">80</span>;<br><span class="hljs-comment">-- 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新</span><br><span class="hljs-comment">-- UPDATE语句不指定WHERE条件时，会作用于表中所有记录</span><br>UPDATE <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> 字段<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2.</span>..;<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表中指定条件的记录</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> ...;<br><br><span class="hljs-comment">-- 当DELETE语句没有找到匹配的where不会报错，也不会删除任何记录</span><br><span class="hljs-comment">-- 不指定where时，DELETE会删除表中所有记录</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br><span class="hljs-comment">-- 在使用DELETE之前，最好先使用SELECT查看WHERE是否选中了期望的记录集，再执行DELETE</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="SQL-DQL-数据查询"><a href="#SQL-DQL-数据查询" class="headerlink" title="SQL DQL:数据查询"></a><strong>SQL DQL:数据查询</strong></h2><ul><li><p>基本查询</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 最普通查询语句</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br><span class="hljs-comment">-- SELECT 语句也可以不带FROM语句，一般用于检查数据库连接状态</span><br><span class="hljs-comment">-- 或是用于计算</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 带条件的投影查询</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ... <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> 条件;<br><br><span class="hljs-comment">-- 使用SELECT进行查询时，查询结果默认按主键排序</span><br><span class="hljs-comment">-- 通过ORDER BY子句指定排序依据的字段，DESC表示倒叙</span><br><span class="hljs-comment">-- 当字段x相同时，再按字段y排序</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ... <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段x <span class="hljs-keyword">DESC</span>, 字段y;<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>分页查询</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 使用SELECT查询时，如果结果集数据量很大，放在一个页面显示的话数据量太大，此时应考虑分页显示</span><br><span class="hljs-comment">-- M表示一页最多M条记录，N表示跳过前N条记录</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ...<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>LIMIT M <span class="hljs-keyword">OFFSET</span> N;<br><br><span class="hljs-comment">-- 注意，查询结果只会显示一页，所以实际上时用OFFSET控制显示第几页</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>聚合查询</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 聚合查询即使用MySQL提供的聚合函数进行查询</span><br><span class="hljs-keyword">SELECT</span> 聚合函数(字段) 别名 <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> 条件;<br><br><span class="hljs-comment">-- 分组聚合使用GROUP BY</span><br><span class="hljs-comment">-- 按多个字段分组</span><br><span class="hljs-keyword">SELECT</span> 聚合函数(字段) 别名 <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段x,字段y...;<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>多表查询</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- SELECT可以同时从多张表查询数据，最后的查询结果是多表的笛卡尔积</span><br><span class="hljs-comment">-- 多个表中有字段名相同的情况，可以使用 "." 运算符明确字段</span><br><span class="hljs-keyword">SELECT</span> 表<span class="hljs-number">1.</span>字段<span class="hljs-number">1</span>,表<span class="hljs-number">2.</span>字段<span class="hljs-number">2</span> ... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>,表<span class="hljs-number">2</span> ... <span class="hljs-keyword">WHERE</span> 条件;<br><br><span class="hljs-comment">-- 不指定条件的表1和表2多表查询最终得到的记录条数为M x N</span><br><span class="hljs-comment">-- 其中M为表1记录条数，N为表2记录条数</span><br><br></code></pre></td></tr></tbody></table></figure></li><li><p>连接查询</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 连接查询的查询结果是多表查询的子集，可以看作特殊的多表查询</span><br><br><span class="hljs-comment">-- 内连接，查询结果是符合连接条件，且在两表中均有的条件字段值的记录集</span><br><span class="hljs-keyword">SELECT</span> 别名<span class="hljs-number">1.</span>字段<span class="hljs-number">1</span>,别名<span class="hljs-number">2.</span>字段<span class="hljs-number">1</span> ...<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-number">1</span><br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> 别名<span class="hljs-number">2</span><br><span class="hljs-keyword">ON</span> 连接条件（等指连接，非等值连接）<br><span class="hljs-keyword">WHERE</span> 查询条件;<br><br><span class="hljs-comment">-- 外连接，以连接的表为基准，查询的记录要包含某一表或所有表的所有记录</span><br><span class="hljs-comment">-- 分为左外连接，右外连接和全外连接</span><br><span class="hljs-keyword">SELECT</span> 别名<span class="hljs-number">1.</span>字段<span class="hljs-number">1</span>,别名<span class="hljs-number">2.</span>字段<span class="hljs-number">1</span> ...<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-number">1</span><br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> 别名<span class="hljs-number">2</span><br><span class="hljs-keyword">ON</span> 连接条件（等指连接，非等值连接）<br><span class="hljs-keyword">WHERE</span> 查询条件;<br></code></pre></td></tr></tbody></table></figure></li><li><p>UNION操作</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</span><br><span class="hljs-comment">-- UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</span><br><br><span class="hljs-comment">-- UNION默认最终保留所有不重复的记录</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span>;<br><br><span class="hljs-comment">-- 若要保留所有重复记录使用UNION ALL</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span> ... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span>;<br></code></pre></td></tr></tbody></table></figure></li><li><p>HAVING子句</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- HAVING子句可以为分组或聚合指定过滤条件</span><br><span class="hljs-keyword">SELECT</span> <br>    字段<span class="hljs-number">1</span>,<br>    聚合函数<span class="hljs-number">1</span>,<br>    聚合函数<span class="hljs-number">2</span><br>    ...<br><span class="hljs-keyword">FROM</span><br>    表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组条件<br><span class="hljs-keyword">HAVING</span> 筛选条件;<br><span class="hljs-comment">-- HAVING子句将过滤条件应用于每组，而WHERE子句将过滤条件应用于每个单独的行。</span><br><span class="hljs-comment">-- 如果省略GROUP BY子句，则HAVING子句的行为与WHERE子句类似。</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>MySQL中的三值逻辑</p><ul><li>在关系型数据库中，由于NULL值的存在，导致逻辑表达式存在三种值：TRUE/FALSE/UNKNOWN。</li><li>在筛选操作中（WHERE-查询、ON-连接、HAVING-分组/聚合）UNKNOWN当作FALSE，即只有TRUE才会被选中</li><li>任何值和NULL做比较运算都返回UNKNOWN（包括NULL自身）</li><li>判断是否为NULL时想返回TRUE或FALSE使用IS</li><li>安全等于&lt;=&gt;也可以在比较普通类型值和NULL时返回TRUE或FALSE</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Basic-SQL&quot;&gt;&lt;a href=&quot;#Basic-SQL&quot; class=&quot;headerlink&quot; title=&quot;Basic SQL&quot;&gt;&lt;/a&gt;Basic SQL&lt;/h1&gt;&lt;p&gt;数据库语言可分为两个部分，DDL和DML。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DDL（Dat</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Fuction</title>
    <link href="http://example.com/2023/02/16/mysql_5/"/>
    <id>http://example.com/2023/02/16/mysql_5/</id>
    <published>2023-02-16T07:30:13.035Z</published>
    <updated>2023-02-16T07:30:13.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fuction"><a href="#Fuction" class="headerlink" title="Fuction"></a>Fuction</h1><p>MySQL中实现了许多内置函数，为DQL提供了更丰富的功能，能更高效的处理查询出的记录。<br>以下列举部分函数及用法</p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a><strong>字符串函数</strong></h2><ul><li>ASCII(s)<br>返回字符串s的第一个字符的ASCII码  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ASCII(CustomerName) <span class="hljs-keyword">AS</span> NumCodeOfFirstChar<br><span class="hljs-keyword">FROM</span> Customers;<br></code></pre></td></tr></tbody></table></figure></li><li>CHAR_LENGTH(s)<br>返回字符串 s 的字符数  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CHAR_LENGTH</span>("RUNOOB") <span class="hljs-keyword">AS</span> LengthOfString;<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a><strong>数字函数</strong></h2><ul><li>ABS(x)<br>返回x的绝对值  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ABS</span>(<span class="hljs-number">-1</span>);<br></code></pre></td></tr></tbody></table></figure></li><li>TAN(x)<br>求x正切值，单位是弧度  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">TAN</span>(<span class="hljs-number">-1</span>);<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a><strong>日期函数</strong></h2><ul><li>CURRENT_DATE()<br>返回当前日期  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_DATE</span>();<br></code></pre></td></tr></tbody></table></figure></li><li>DAY(d)<br>返回日期d的日部分  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DAY</span>(d);<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a><strong>其他函数</strong></h2><ul><li>CURRENT_DATE()<br>返回当前日期  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_DATE</span>();<br></code></pre></td></tr></tbody></table></figure></li><li>CAST(x AS type)<br>转换数据类型  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>("2017-08-29" <span class="hljs-keyword">AS</span> <span class="hljs-type">DATE</span>);;<br></code></pre></td></tr></tbody></table></figure></li><li>CASE<br>case语句<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> x<br>       <span class="hljs-keyword">WHEN</span> x<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'x&gt;0'</span><br>       <span class="hljs-keyword">WHEN</span> x<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'x=0'</span><br>       <span class="hljs-keyword">ELSE</span> <span class="hljs-string">'x&lt;0'</span><br>       <span class="hljs-keyword">END</span><br></code></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Fuction&quot;&gt;&lt;a href=&quot;#Fuction&quot; class=&quot;headerlink&quot; title=&quot;Fuction&quot;&gt;&lt;/a&gt;Fuction&lt;/h1&gt;&lt;p&gt;MySQL中实现了许多内置函数，为DQL提供了更丰富的功能，能更高效的处理查询出的记录。&lt;br&gt;以下</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>View</title>
    <link href="http://example.com/2023/02/15/mysql_6/"/>
    <id>http://example.com/2023/02/15/mysql_6/</id>
    <published>2023-02-15T13:24:56.494Z</published>
    <updated>2023-02-15T13:24:56.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View"><a href="#View" class="headerlink" title="View"></a>View</h1><h2 id="视图的概念"><a href="#视图的概念" class="headerlink" title="视图的概念"></a><strong>视图的概念</strong></h2><ul><li>视图是由数据库中的一个表或多个表导出的虚拟表，其内容由查询定义,作用是方便用户对数据的操作。数据库中只存放了视图的定义，而并没有存放视图中的数据，这些数据存放在原来的表中。</li><li>视图依赖的数据发生改变时，视图也跟着改变。视图本身发生改变也会影响到原数据。</li><li>MySQL中视图的本质其实一组DQL语句，即数据库中只存放视图的定义，而不会单独为视图开辟额外的空间存放数据的拷贝。</li></ul><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a><strong>视图的作用</strong></h2><ul><li>简化操作<br>视图需要达到的目的就是所见即所需。视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li><li>增加数据安全性<br>通过视图，用户只能查询和修改指定的数据。指定数据之外的信息，用户根本接触不到。这样可以防止敏感信息被未授权的用户查看，增强机密信息的安全性。</li><li>提高表的逻辑独立性<br>视图可以屏蔽原有表结构变化带来的影响。例如原有表增加列和删除未被引用的列，对视图不会造成影响。同样，如果修改表中的某些列，可以使用修改视图来解决这些列带来的影响。</li></ul><h2 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a><strong>视图的操作</strong></h2><ul><li><p>创建/修改视图</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 加上OR REPLACE时，如果视图已经存在，则直接修改视图</span><br><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] [ALGORITHM<span class="hljs-operator">=</span>算法名]<br><span class="hljs-keyword">VIEW</span> 视图名[(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>，...)]<br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span>语句<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>删除视图</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> IF <span class="hljs-keyword">EXISTS</span> 视图名<br></code></pre></td></tr></tbody></table></figure></li><li><p>查看视图</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESCRIBE</span> 视图名<br></code></pre></td></tr></tbody></table></figure></li><li><p>查询视图<br>和查询表的语句完全一样</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;View&quot;&gt;&lt;a href=&quot;#View&quot; class=&quot;headerlink&quot; title=&quot;View&quot;&gt;&lt;/a&gt;View&lt;/h1&gt;&lt;h2 id=&quot;视图的概念&quot;&gt;&lt;a href=&quot;#视图的概念&quot; class=&quot;headerlink&quot; title=&quot;视图的概念&quot;&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>User Rights Management</title>
    <link href="http://example.com/2023/02/13/mysql_4/"/>
    <id>http://example.com/2023/02/13/mysql_4/</id>
    <published>2023-02-13T13:28:30.354Z</published>
    <updated>2023-02-13T13:28:30.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="User-Rights-Management"><a href="#User-Rights-Management" class="headerlink" title="User Rights Management"></a>User Rights Management</h1><p>MySQL的用户权限管理即通过划分用户，为不同用户在dbms中提供不同的权力。MySQL服务器通过权限表来控制用户对数据库的操作，权限表存放在mysql数据库中，由mysql_install_db脚本初始化。<br>存储账户权限信息表（在dbms中一个名为mysql的数据库中存储）主要有：user、db、tables_priv、columns_priv、procs_priv、proxies_priv这六张表（5.6之前还有host表，现在已经把host内容整合进user表）</p><h2 id="有哪些权限"><a href="#有哪些权限" class="headerlink" title="有哪些权限"></a><strong>有哪些权限</strong></h2><p>MySQL中的用户权限包括连接权限和操作权限两大部分。</p><h3 id="连接权限"><a href="#连接权限" class="headerlink" title="连接权限"></a>连接权限</h3><p>连接权限用于设置用户是否有权登录到dbms中，权限信息（字段）包括host（从哪来）、user（用户名）及password（密码），保存于user表中。</p><h3 id="操作权限"><a href="#操作权限" class="headerlink" title="操作权限"></a>操作权限</h3><p>mysql对用户的操作权限信息保存在名为mysql的数据库的如下六个表中：user、db、tables_priv、columns_priv、proce_priv、proxies_priv。每一个表都记录的每个用户的各类操作权限（如查询、修改、删除等权限）。<br>下面是各个表的具体权限分类。  </p><ul><li>user表：user表列出可以连接服务器的用户及其口令，并且它指定他们有哪种全局（超级用户）权限。在user表启用的任何权限均是全局权限，并适用于所有数据库。例如，如果你启用了DELETE权限，在这里列出的用户可以从任何表中删除记录，所以在你这样做之前要认真考虑。</li><li>db表：db表列出数据库，而用户有权限访问它们。在这里指定的权限适用于一个数据库中的所有表。</li><li>tables_priv表：tables_priv表指定表级权限，在这里指定的一个权限适用于一个表的所有列。</li><li>columns_priv表：columns_priv表指定列级权限。这里指定的权限适用于一个表的特定列。</li><li>proce_priv：columns_priv表指定存储过程权限。这里代表允许使用某个存储过程的权限。</li><li>proxies_priv：利用 MySQL proxies_priv（模拟角色）实现类似用户组管理。角色(Role)可以用来批量管理用户，同一个角色下的用户，拥有相同的权限。</li></ul><p>注意，某一用户登录dbms后要进行某一操作时，其权限检查按上述表顺序由上至下依次检查，当在某一表中权限检查通过，直接执行操作而不用继续检查。</p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a><strong>实际操作</strong></h2><p>在MySQL中对用户权限进行创建、修改和删除时，均可以直接使用DML在上述权限表中进行操作。<br>另外MySQL也提供了一些命令，可以使用户在MySQL终端中修改用户权限，避免了用户直接修改系统数据库，主要命令如下：</p><ul><li>创建用户：<code>create user [用户名]@[访问地址] identified by [密码];</code><ul><li>当访问地址为%时表示不限制访问host</li></ul></li><li>授予权限：<code>grant [权限1,权限2,权限3] on *.* to user@'host' identified by 'password';</code><ul><li>all privileges：表示将所有权限授予给用户。也可指定具体的权限，如：SELECT、CREATE、DROP等</li><li>on：表示这些权限对哪些数据库和表生效，格式：数据库名.表名，这里写“*”表示所有数据库，所有表。如果我要指定将权限应用到test库的user表中，可以这么写：test.user</li><li>to：将权限授予哪个用户。格式：”用户名”@”登录IP或域名”。%表示没有限制，在任何主机都可以登录。比如：‘zhangsan‘@’192.168.1.%’，表示zhangsan这个用户只能在192.168.0.* IP段登录</li><li>with grant option：通过在grant语句的最后使用该子句，就允许被授权的用户把得到的权限继续授给其它用户</li></ul></li><li>修改权限<ul><li>收回权限：<code>revoke [权限] ON *.* FROM admin@'localhost';</code></li><li>删除用户：<code>drop user admin@'localhost';</code></li></ul></li></ul><p>注意，每次进行权限的授予和修改后，要及时刷新权限：<code>flush privileges;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;User-Rights-Management&quot;&gt;&lt;a href=&quot;#User-Rights-Management&quot; class=&quot;headerlink&quot; title=&quot;User Rights Management&quot;&gt;&lt;/a&gt;User Rights Manageme</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Engine</title>
    <link href="http://example.com/2023/02/13/mysql_3/"/>
    <id>http://example.com/2023/02/13/mysql_3/</id>
    <published>2023-02-13T12:25:58.462Z</published>
    <updated>2023-02-13T12:25:58.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h1><p>数据库存储引擎,又称数据表处理器，它是数据库底层软件的组织。数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p><h2 id="MySql中的存储引擎"><a href="#MySql中的存储引擎" class="headerlink" title="MySql中的存储引擎"></a><strong>MySql中的存储引擎</strong></h2><p>和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部包含了多种数据引擎，常见的包括：</p><ul><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ul><p>MySQL内部包含了共九种数据引擎，详细信息见下图。<br><img src="/images/mysql/4.jpg"><br>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h2><p>InnoDB是MySQL的默认引擎，也是目前最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务（大部分情况能正常提交，很少被回滚）。同时，InnoDB的性能和崩溃自动恢复特性使得它在非事务型储存的需求中也被广泛使用。若非有特别原因需要使用其他的储存引擎，建议优先考虑InnoDB引擎。<br>主要特性：</p><ul><li>支持事务</li><li>灾难恢复性好</li><li>为处理巨大数据量的最大性能设计</li><li>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取</li><li>支持外键完整性约束。存储表中的数据时，每张表的存储都按逐渐顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6B的ROWID,并以此作为主键</li><li>被用在众多需要高性能的大型数据库站点上</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h2><p>MyISAM 基于 ISAM 的存储引擎，并对其进行扩展。它是在Web、数据存储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。在 MySQL5.5.5 之前的版本中，MyISAM 是默认的存储引擎。使用 MyISAM 引擎创建数据库，将产生3个文件。文件的名字以表的名字开始，扩展名指出文件类型：frm 文件存储表定义，数据文件的扩展名为 .MYD（MYData），索引文件的扩展名是 .MYI（MYIndex）。<br>主要特性：</p><ul><li>不支持事务</li><li>使用表级锁，并发性差</li><li>主机宕机后，MyISAM表易损坏，灾难恢复性不佳</li><li>只缓存索引，数据的缓存是利用操作系统缓冲区来实现的。可能引发过多的系统调用且效率不佳</li><li>数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能</li><li>可以把数据文件和索引文件放在不同目录</li></ul><h2 id="InnoDB与MyISAM的对比"><a href="#InnoDB与MyISAM的对比" class="headerlink" title="InnoDB与MyISAM的对比"></a><strong>InnoDB与MyISAM的对比</strong></h2><p>不同存储引擎都有各自的特点，以适应不同的需求，下表罗列了一些InnoDB与MyISAM功能上的不同点。<br><img src="/images/mysql/5.jpg"></p><table><thead><tr><th>差异点</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>构成上的区别</td><td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。存储表定义文件扩展名为.frm；数据文件的扩展名为.MYD (MYData)；索引文件的扩展名是.MYI (MYIndex)。</td><td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。</td></tr><tr><td>事务处理上方面</td><td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持。</td><td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td></tr><tr><td>SELECT   UPDATE,INSERT，Delete操作</td><td>如果执行大量的SELECT，MyISAM是更好的选择；DELETE   FROM table时，MyISAM会重新建立表（更快）。</td><td>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表；DELETE   FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</td></tr><tr><td>表的具体行数</td><td>select count(*) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(*)语句包含where条件时，两种表的操作是一样的</td><td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行</td></tr><tr><td>锁</td><td>表锁</td><td>提供行锁，提供与 Oracle 类型一致的不加锁读取，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</td></tr></tbody></table><p>总之，MyISAM更注重性能，InnoDB提供的功能更多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Engine&quot;&gt;&lt;a href=&quot;#Engine&quot; class=&quot;headerlink&quot; title=&quot;Engine&quot;&gt;&lt;/a&gt;Engine&lt;/h1&gt;&lt;p&gt;数据库存储引擎,又称数据表处理器，它是数据库底层软件的组织。数据库管理系统（DBMS）使用数据引擎进行创建、</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL Datatype</title>
    <link href="http://example.com/2023/02/10/mysql_2/"/>
    <id>http://example.com/2023/02/10/mysql_2/</id>
    <published>2023-02-10T13:47:18.173Z</published>
    <updated>2023-02-10T13:47:18.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-Datatype"><a href="#MySQL-Datatype" class="headerlink" title="MySQL Datatype"></a>MySQL Datatype</h1><p>mysql 数据类型反应在列（字段上），不同记录在同一字段上的分量数据类型相同。mysql支持多种数据类型，大致分为三类：数值、日期/时间、字符串（字符）。选取类型的准则是在满足数据需求的情况下尽量选择范围小的数据类型。</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a><strong>数值类型</strong></h2><p>mysql 支持所有标准 SQL 数值数据类型，这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC等)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION等)。BIT数据类型保存位字段值。<br>所有数值类型详细信息见下图。<br><img src="/images/mysql/1.jpg"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>bit类型会以二进制形式显示数值。</li><li>decimal中的M和D分别代表记录数值的总位数和小数位数，一般需求非常高精度数据或有很大数时使用decimal类型</li></ul><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a><strong>字符类型</strong></h2><p>下图展示了 mysql 字符数据类型的详细信息。<br><img src="/images/mysql/2.jpg"></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数</li><li>char 定长，记录分量存储时自动补齐空格至指定长度个字符，即为记录分配定长空间</li><li>varchr 不定长，不补齐空格，分配空间按实际计算，分配大小为实际数据字节大小+1-3个字节（用于存放实际实际长度）</li></ul><h2 id="日期-时间类型"><a href="#日期-时间类型" class="headerlink" title="日期/时间类型"></a><strong>日期/时间类型</strong></h2><p>下图展示了 mysql 日期/时间数据类型的详细信息。<br><img src="/images/mysql/2.jpg"></p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>时间类型其实是格式化的字符串，如当插入一条date类型的记录分量时，使用这样的语句<code>INSERT INTO date_table(dt) VALUES('2023-02-07')</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-Datatype&quot;&gt;&lt;a href=&quot;#MySQL-Datatype&quot; class=&quot;headerlink&quot; title=&quot;MySQL Datatype&quot;&gt;&lt;/a&gt;MySQL Datatype&lt;/h1&gt;&lt;p&gt;mysql 数据类型反应在列（字段上），不同</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Inversion of Control</title>
    <link href="http://example.com/2022/09/15/IoC/"/>
    <id>http://example.com/2022/09/15/IoC/</id>
    <published>2022-09-15T11:31:53.922Z</published>
    <updated>2022-09-15T11:31:53.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a>Inversion of Control</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><h3 id="DIP、IoC、DI、SL-是什么"><a href="#DIP、IoC、DI、SL-是什么" class="headerlink" title="DIP、IoC、DI、SL 是什么"></a>DIP、IoC、DI、SL 是什么</h3><ul><li><p><strong>DIP</strong>，即依赖倒置原则（Dependency inversion principle），不是一种技术，而是一种面向对象设计思想，其使得高层次的类不依赖于低层次的类的实现细节，依赖关系被倒置（高低层次的类都反而依赖接口），从而使得低层次类依赖于高层次类的需求抽象。</p></li><li><p><strong>IoC</strong>，即控制反转（Inversion of Control）。也是一种面向对象设计思想，是相对于DIP更进一步的解耦（连在所需类中自行创建具体的对象也不需要）。实现方式便是将用户或框架设计好的对象交给容器控制，而非传统编程过程中在其他对象内部控制，这种方式在现代的web开发、图像开发中很常用。</p></li><li><p><strong>SL</strong>，即服务定位器（Service Locator）。是IoC的一种具体实现方法，实现了按需返回服务实例，在该模式中，服务会被提前注册到服务定位器中，并通过 ID 唯一标识。应用需要某个服务时，通过 ID 或所需类型从服务定位器中得到这个服务的实例。服务定位器解耦了服务调用者和具体的服务实现。</p></li><li><p><strong>DI</strong>，即依赖注入（Dependency Injection）。是IoC的一种具体实现方法，组件之间的依赖关系由容器在 <em>运行期间</em> 自行决定（使用反射技术），由容器动态地将依赖项注入到组件当中。</p></li></ul><h3 id="IoC-DI的优点"><a href="#IoC-DI的优点" class="headerlink" title="IoC/DI的优点"></a>IoC/DI的优点</h3><ul><li><p>没有引入IOC之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，A直接使用new关键字创建B的实例，程序高度耦合，效率低下，无论是创建还是使用B对象，控制权都在自己手上。</p></li><li><p>传统的代码，每个对象负责管理与自己需要依赖的对象，导致如果需要切换依赖对象的实现类时，需要修改很多地方。同时，过度耦合也使得对象难以进行单元测试。</p></li><li><p>实现IoC之后，依赖关系高度解耦，在可见的代码中不需要手动new，这个过程被推迟到运行过程中由容器动态控制，使单元测试、程序修改更加方便，并且解放了程序员在大型程序复杂依赖的手动控制。</p></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ul><li>传统编程</li></ul><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//需要手动创建依赖实例,更换某一组件时，组件和应用代码都要更改</span><br>DialModule dialModule = <span class="hljs-keyword">new</span> DialModule();<br>VideoPlayerModule videoplayerModule=<span class="hljs-keyword">new</span> VideoPlayerModule();<br>Phone phone=<span class="hljs-keyword">new</span> Phone(videoplayerModule,dialModule);<br><br>phone.Play(<span class="hljs-keyword">new</span> Video(<span class="hljs-string">"the Suit"</span>, <span class="hljs-number">120</span>));<br>phone.Dial(<span class="hljs-string">"2838896"</span>);<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DialModule</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">$"calling <span class="hljs-subst">{phone_number}</span>..."</span>);<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Video</span><br>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; }<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Period { <span class="hljs-keyword">get</span>; }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Video</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> period</span>)</span><br>    {<br>        Name=name;<br>        Period=period;<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">VideoPlayerModule</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Play</span>(<span class="hljs-params">Video video</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">$"playing <span class="hljs-subst">{video.Name}</span>"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span><br>{<br>    <span class="hljs-keyword">private</span> VideoPlayerModule _videoPlayerModule;<br>    <span class="hljs-keyword">private</span> DialModule _dialModule;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span>(<span class="hljs-params">VideoPlayerModule videoPlayerModule, DialModule dialModule</span>)</span><br>    {<br>        _videoPlayerModule = videoPlayerModule;<br>        _dialModule = dialModule;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        _dialModule.Dial(phone_number);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Play</span>(<span class="hljs-params">Video video</span>)</span><br>    {<br>        _videoPlayerModule.Play(video);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>接口编程（DIP）</li></ul><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//需要手动创建依赖实例,更换某一组件时，只需要在这里改</span><br>IDial dialModule = <span class="hljs-keyword">new</span> CommonDial();<br><br>Phone phone=<span class="hljs-keyword">new</span> Phone(dialModule);<br><br>phone.Dial(<span class="hljs-string">"xxxxxxx"</span>);<br><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IDial</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">CommonDial</span>:<span class="hljs-title">IDial</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">$"calling <span class="hljs-subst">{phone_number}</span>..."</span>);<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateDial</span> : <span class="hljs-title">IDial</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">$"secretly calling <span class="hljs-subst">{phone_number}</span>..."</span>);<br>    }<br>}<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span><br>{<br>    <br>    <span class="hljs-keyword">private</span> IDial _dialModule;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span>(<span class="hljs-params">IDial dialModule</span>)</span><br>    {<br>        <br>        _dialModule = dialModule;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        _dialModule.Dial(phone_number);<br>    }<br><br>    <br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>控制反转（IoC）</li></ul><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//微软提供的依赖注入扩展</span><br><span class="hljs-keyword">using</span> Microsoft.Extensions.DependencyInjection;<br><br><br><span class="hljs-comment">//实例化一个容器</span><br>IServiceCollection services=<span class="hljs-keyword">new</span> ServiceCollection();<br><span class="hljs-comment">//注册服务</span><br>services.AddScoped&lt;IDial, CommonDial&gt;();<br>services.AddScoped&lt;IDial, PrivateDial&gt;();<br>services.AddScoped&lt;Phone&gt;();<br><br><span class="hljs-comment">//获取服务定位器</span><br><span class="hljs-keyword">var</span> provider=services.BuildServiceProvider();<br><span class="hljs-comment">//首个实例的创建需要使用服务定位器的方式获得</span><br><span class="hljs-comment">//之后的依赖，通过依赖注入的方式在运行中由容器分配</span><br>Phone? phone=provider.GetService&lt;Phone&gt;();<br><br><span class="hljs-keyword">if</span>(phone!=<span class="hljs-literal">null</span>)<br>{<br>    phone.Dial(<span class="hljs-string">"xxxxxxxxxxxx"</span>);<br>}<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IDial</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">CommonDial</span>:<span class="hljs-title">IDial</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">$"calling <span class="hljs-subst">{phone_number}</span>..."</span>);<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateDial</span> : <span class="hljs-title">IDial</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">$"secretly calling <span class="hljs-subst">{phone_number}</span>..."</span>);<br>    }<br>}<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span><br>{<br>    <br>    <span class="hljs-keyword">private</span> IDial _dialModule;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span>(<span class="hljs-params">IDial dialModule</span>)</span><br>    {<br>        <br>        _dialModule = dialModule;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dial</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> phone_number</span>)</span><br>    {<br>        _dialModule.Dial(phone_number);<br>    }<br><br>    <br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Inversion-of-Control&quot;&gt;&lt;a href=&quot;#Inversion-of-Control&quot; class=&quot;headerlink&quot; title=&quot;Inversion of Control&quot;&gt;&lt;/a&gt;Inversion of Control&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Computer Literacy" scheme="http://example.com/categories/Computer-Literacy/"/>
    
    
    <category term="IoC" scheme="http://example.com/tags/IoC/"/>
    
    <category term="DI" scheme="http://example.com/tags/DI/"/>
    
    <category term="DIP" scheme="http://example.com/tags/DIP/"/>
    
    <category term="Design Patterns" scheme="http://example.com/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Asynchronous programming</title>
    <link href="http://example.com/2022/09/15/AsyncAwait/"/>
    <id>http://example.com/2022/09/15/AsyncAwait/</id>
    <published>2022-09-15T01:46:23.596Z</published>
    <updated>2022-09-15T01:46:23.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Asynchronous-programming"><a href="#Asynchronous-programming" class="headerlink" title="Asynchronous programming"></a>Asynchronous programming</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a>Concept and Principle</h2><ul><li><p>异步编程与多线程编程</p><ul><li>异步编程一般在单线程（或线程池）上实现并发执行，不涉及线程切换，减小了维护多线程的开销。而多线程编程在多核处理器上做并行执行，需要考虑线程间同步以及线程切换等问题</li><li>异步编程适合于I/O密集型操作，而多线程编程适合于计算密集型工作。这是因为在I/O过程中线程会被阻塞但依然要维护其占用的内存资源，并且还有进行线程切换开销；而异步编程则避免了这些问题，将I/O操作封装为异步函数，cpu在执行到I/O操作时向DMA发送指令后直接执行其他代码，当I/O操作结束后执行回调</li></ul></li><li><p>async/await 结构</p><ul><li>async与await被许多语言都设置为了异步编程的语法糖，有多种实现（如python中的coroutine、c#中的Task、js中的promise）。</li><li>async/await 结构可分成三部分：<ol><li>调用方法：该方法调用异步方法，在异步方法执行其任务的时候继续执行该方法下其他代码</li><li>异步方法：在执行完成前立即返回调用方法，在调用方法继续执行的过程中完成任务</li><li>await 表达式：用于异步方法内部，指出需要异步执行的任务(在await之前的代码还都是同步执行)。一个异步方法可以包含多个 await 表达式，当异步方法中不包含await表达式时，将会同步执行（顺序执行）异步方法</li></ol></li></ul></li><li><p>async/await执行过程</p><ol><li>调用方法执行到由async修饰的异步方法，进入该方法先同步执行</li><li>顺序执行到await修饰的语句，调用该语句后立即返回原调用方法</li><li>在原调用方法中继续执行后面的代码，同时异步方法也在执行await的语句</li></ol></li><li><p>注意</p><ul><li>调用方法和异步方法可能是并行的，也可能是并发的，这方面不需要程序员考虑，只需要知道异步方法的执行不影响调用方法的执行</li><li>异步方法正常的返回值并不是方法内指明的返回值（python中返回coroutine、c#中返回Task、js中返回promise），但用await修饰会直接返回异步方法内指明的返回值</li><li>如果异步方法还未执行完，而在调用方法中就要使用异步方法的result，则会死等到异步方法执行完毕</li><li>异步方法一般回调联合使用</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><ul><li><p>c#中实现的异步编程基于Task，底层是线程池</p>  <figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>App app = <span class="hljs-keyword">new</span> App();<br>app.Run();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">NeuralNetwork</span><br>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Acc { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Loss { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NeuralNetwork</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    {<br>        _name = name;<br>    }<br><br>    <span class="hljs-comment">//训练结束后调用回调函数</span><br>    <span class="hljs-comment">//由于是异步方法，其不会阻塞界面线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TrainAsync</span>(<span class="hljs-params">Action&lt;<span class="hljs-built_in">double</span>, <span class="hljs-built_in">double</span>&gt; action</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">"我之前还是同步执行"</span>);<br>        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">3000</span>);<br>        Acc = <span class="hljs-number">0.9f</span>;<br>        Loss = <span class="hljs-number">0.00466f</span>;<br>        action(Acc, Loss);<br>    }<br><br>    <span class="hljs-comment">//虽然也是异步方法，但方法完成后不会通知调用方法，在此场景下还是低效</span><br>    <span class="hljs-comment">//在不需要回调的情境下可以使用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;Tuple&lt;<span class="hljs-built_in">double</span>, <span class="hljs-built_in">double</span>&gt;&gt; TrainAsync()<br>    {<br>        Console.WriteLine(<span class="hljs-string">"我之前还是同步执行"</span>);<br><br>        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">3000</span>);<br>        Acc = <span class="hljs-number">0.9f</span>;<br>        Loss = <span class="hljs-number">0.00466f</span>;<br><br>        <span class="hljs-keyword">return</span> Tuple.Create(Acc, Loss);<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">App</span><br>{<br>    <span class="hljs-keyword">private</span> NeuralNetwork _network = <span class="hljs-keyword">new</span> NeuralNetwork(<span class="hljs-string">"Cnn"</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RunWithCallBack</span>(<span class="hljs-params"></span>)</span><br>    {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++)<br>        {<br>            Thread.Sleep(<span class="hljs-number">500</span>);<br>            Console.WriteLine(<span class="hljs-string">"running..."</span>);<br><br>            <span class="hljs-comment">//模拟训练模型，需要长时间操作</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<br>                <span class="hljs-comment">//进入到函数中，执行到调用await后立即返回到RunWithCallBack继续执行</span><br>                _network.TrainAsync(<span class="hljs-keyword">this</span>.Show);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"></span>)</span><br>    {<br>        Task&lt;Tuple&lt;<span class="hljs-built_in">double</span>, <span class="hljs-built_in">double</span>&gt;&gt; t = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++)<br>        {<br><br>            Thread.Sleep(<span class="hljs-number">500</span>);<br>            Console.WriteLine(<span class="hljs-string">"running..."</span>);<br>            <br><br>            <span class="hljs-comment">//模拟训练模型，需要长时间操作</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<br>            {<br>                <span class="hljs-comment">//如果在这里直接输出，则依然会产生阻塞的效果</span><br>                <span class="hljs-comment">//Console.WriteLine(_network.TrainAsync().Result);</span><br><br>                <span class="hljs-comment">//使用await，await返回的直接就是_network.TrainAsync().Result</span><br>                t = _network.TrainAsync();<br><br>            }<br><br>            <span class="hljs-comment">//在第十次刷新时检查是否训练完成，没完成继续等</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">10</span>)<br>                Console.WriteLine(t.Result);<br><br>        }<br><br><br>    }<br><br>    <span class="hljs-comment">//界面展示精度与损失</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> acc, <span class="hljs-built_in">double</span> loss</span>)</span><br>    {<br>        Console.WriteLine(<span class="hljs-string">$"acc:<span class="hljs-subst">{acc}</span>,loss:<span class="hljs-subst">{loss}</span>"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>python实现的异步编程使用了协程概念，与JS一样底层都是单线程</p>  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#asyncio包帮助实现异步编程</span><br><span class="hljs-comment">#将所有异步和同步函数加入一个事件循环，在这个循环内按异步定义为每个函数分配时间片</span><br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">RunNN</span>(<span class="hljs-params">f</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"===="</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <br>    loss=<span class="hljs-number">0.0045</span><br>    acc=<span class="hljs-number">0.97</span><br>    f(loss,acc)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">app</span>():</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"running..."</span>)<br>        <br><br>asyncio.gather(app(), RunNN(<span class="hljs-keyword">lambda</span> x, y: <span class="hljs-built_in">print</span>(<span class="hljs-string">f"loss:<span class="hljs-subst">{x}</span>,acc<span class="hljs-subst">{y}</span>"</span>)))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(app(), RunNN(<span class="hljs-keyword">lambda</span> x, y: <span class="hljs-built_in">print</span>(<span class="hljs-string">f"loss:<span class="hljs-subst">{x}</span>,acc<span class="hljs-subst">{y}</span>"</span>)))<br><br>asyncio.run(main())<br><br></code></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Asynchronous-programming&quot;&gt;&lt;a href=&quot;#Asynchronous-programming&quot; class=&quot;headerlink&quot; title=&quot;Asynchronous programming&quot;&gt;&lt;/a&gt;Asynchronous p</summary>
      
    
    
    
    <category term="Computer Literacy" scheme="http://example.com/categories/Computer-Literacy/"/>
    
    
    <category term="Asynchronous-programming" scheme="http://example.com/tags/Asynchronous-programming/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Object Detection</title>
    <link href="http://example.com/2022/09/15/d2l_20/"/>
    <id>http://example.com/2022/09/15/d2l_20/</id>
    <published>2022-09-15T01:45:20.166Z</published>
    <updated>2022-09-15T01:45:20.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-Detection"><a href="#Object-Detection" class="headerlink" title="Object Detection"></a>Object Detection</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><p>目标检测任务与图像分类不同，目标检测要在图片中识别出多个不同的目标并表明每个目标的位置</p><ul><li><p>边缘框</p><ul><li>边缘框表示了目标的位置，有两种坐标表示法<ul><li>(左上x，左上y，右下x，右下y)</li><li>(左上x，左上y，边框宽，边框高)</li></ul></li></ul></li><li><p>锚框</p><ul><li>锚框在目标检测算法中很常用，许多目标检测算法都用到了这项技术</li><li>锚框是对边缘框的一个猜测：<ul><li>提出多个被称为锚框的区域</li><li>预测每个锚框中是否含有目标物体</li><li>如果有，则继续预测从这个锚框到真实边缘框的偏移</li></ul></li><li>使用交并比（IoU）来计算两个框的相似度(预测框和标签框)<br><img src="/images/d2l/20/1.png"></li><li>赋予锚框标号<ul><li>在训练时，每个锚框都是一个训练样本，每次读取一张图片都要进行一次赋予锚框标号的操作</li><li>将每个锚框要么标注为背景，要么标注为与真实边缘框相关</li><li>可能生成大量锚框导致负样本过多</li><li>锚框可固定生成，或根据图片生成，甚至随机</li><li>假设一个图片有4个标签边缘框，生成了9个锚框，一种赋予标号的算法如下图<br><img src="/images/d2l/20/2.png"></li></ul></li><li>在预测时，使用非极大值抑制（NMS）输出<br><img src="/images/d2l/20/3.png"></li></ul></li><li><p>目标检测常用算法</p><ol><li><p>Faster R-CNN<br>图片进入一个CNN后分成两条路线，一条路线进入RPN（负责生成锚框），另一条路线经过RoI pooling（将不同大小的锚框提取为同一大小）后连接至全连接层，最后做出分类以及边缘框预测。Faster R-CNN相对其他算法来说还是很慢，但精度很高，适合刷榜。<br><img src="/images/d2l/20/4.png"></p></li><li><p>SSD（单发多框检测）<br>SSD由一个基础的网络来抽取特征，然后多个卷积层块来减半高宽。每段都会生成锚框，底部段拟合小物体，顶部段拟合大物体。每个锚框都会预测类别和边缘框<br><img src="/images/d2l/20/5.png"></p></li><li><p>YOLO<br>SSD中锚框有大量重叠，YOLO将图片均匀分成SxS个锚框，每个锚框预测B个边缘框。</p></li></ol></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ul><li><p>边缘框实现</p>  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img=Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">"./1.jpg"</span>)<br>plt.imshow(img)<br>plt.show()<br>fig=plt.imshow(img)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">box_corner_to_center</span>(<span class="hljs-params">boxes</span>):</span><br>    <span class="hljs-string">"""(左上，右下)转换到(中间，宽度，高度)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        boxs : 一组边缘框 </span><br><span class="hljs-string">    """</span><br>    x1, y1, x2, y2 = boxes[:, <span class="hljs-number">0</span>], boxes[:, <span class="hljs-number">1</span>], boxes[:, <span class="hljs-number">2</span>], boxes[:, <span class="hljs-number">3</span>]<br>    cx = (x1 + x2) / <span class="hljs-number">2</span><br>    cy = (y1 + y2) / <span class="hljs-number">2</span><br>    w = x2 - x1<br>    h = y2 - y1<br>    <span class="hljs-comment"># 将新坐标堆叠起来变为二维Tensor，注意与cat不同</span><br>    boxes = torch.stack((cx, cy, w, h))<br>    <span class="hljs-comment"># 返回转置</span><br>    <span class="hljs-keyword">return</span> boxes.T<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">box_center_to_corner</span>(<span class="hljs-params">boxes</span>):</span><br>    <span class="hljs-string">"""(中间，宽度，高度)转换到(左上，右下)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        boxs : 一组边缘框 </span><br><span class="hljs-string">    """</span><br>    cx, cy, w, h = boxes[:, <span class="hljs-number">0</span>], boxes[:, <span class="hljs-number">1</span>], boxes[:, <span class="hljs-number">2</span>], boxes[:, <span class="hljs-number">3</span>]<br>    x1 = cx - <span class="hljs-number">0.5</span> * w<br>    y1 = cy - <span class="hljs-number">0.5</span> * h<br>    x2 = cx + <span class="hljs-number">0.5</span> * w<br>    y2 = cy + <span class="hljs-number">0.5</span> * h<br>    boxes = torch.stack((x1, y1, x2, y2))<br>    <span class="hljs-keyword">return</span> boxes.T<br><br>x=torch.tensor([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])<br>x=box_corner_to_center(x)<br><span class="hljs-built_in">print</span>(x)<br>x=box_center_to_corner(x)<br><span class="hljs-built_in">print</span>(x)<br><br><br>box1=torch.tensor([<span class="hljs-number">360</span>,<span class="hljs-number">170</span>,<span class="hljs-number">650</span>,<span class="hljs-number">650</span>])<br>box2=torch.tensor([<span class="hljs-number">120</span>,<span class="hljs-number">210</span>,<span class="hljs-number">350</span>,<span class="hljs-number">290</span>])<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_bboxes</span>(<span class="hljs-params">fig,bboxes,color</span>):</span><br>    <span class="hljs-string">"""显示带边缘框的图片</span><br><span class="hljs-string"></span><br><span class="hljs-string">    """</span> <br>    <span class="hljs-keyword">for</span> b,c <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(bboxes,color):<br>        fig.axes.add_patch(_bbox_to_rect(b, c))<br>    plt.show()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_bbox_to_rect</span>(<span class="hljs-params">bbox, color</span>):</span><br>        <span class="hljs-keyword">return</span> plt.Rectangle(xy=(bbox[<span class="hljs-number">0</span>], bbox[<span class="hljs-number">1</span>]), width=bbox[<span class="hljs-number">2</span>] - bbox[<span class="hljs-number">0</span>],<br>                                height=bbox[<span class="hljs-number">3</span>] - bbox[<span class="hljs-number">1</span>], fill=<span class="hljs-literal">False</span>,<br>                                edgecolor=color, linewidth=<span class="hljs-number">2</span>)<br><br><br><br>show_bboxes(fig,[box1,box2],[<span class="hljs-string">'red'</span>,<span class="hljs-string">'green'</span>])<br><br></code></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Object-Detection&quot;&gt;&lt;a href=&quot;#Object-Detection&quot; class=&quot;headerlink&quot; title=&quot;Object Detection&quot;&gt;&lt;/a&gt;Object Detection&lt;/h1&gt;&lt;h2 id=&quot;Concept-a</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Fine Tune</title>
    <link href="http://example.com/2022/09/15/d2l_19/"/>
    <id>http://example.com/2022/09/15/d2l_19/</id>
    <published>2022-09-15T01:45:16.954Z</published>
    <updated>2022-09-15T01:45:16.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fine-Tune"><a href="#Fine-Tune" class="headerlink" title="Fine Tune"></a>Fine Tune</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><ul><li><p>一般神经网络的架构都分为两块：</p><ul><li>特征抽取部分</li><li>线性分类部分<br><img src="/images/d2l/19/1.png"></li></ul></li><li><p>微调  </p><ul><li><p>一个模型特征提取部分可以作为上游模型训练其他任务<br><img src="/images/d2l/19/2.png"></p></li><li><p>pre-train的过程一般是一个大数据集上的正常训练任务，而在fine-tune的过程中使用更强的正则化、更小的学习率、更少的epoch</p></li><li><p>原数据集和目标数据集要相似，且原数据集比目标数据集要大</p></li></ul></li><li><p>微调的一些技巧</p><ul><li>重用分类器权重：原数据集中也可能有下游任务数据的部分标号，可以用预训练模型分类器中对应标号的对应向量来初始化下游任务分类部分</li><li>固定前面的层：神经网络中靠近输入的层更加通用，可以固定底部的一些层的参数不参与更新</li><li>对于个人或小企业来说，通常不会从头开始训练模型，而是进行微调</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> models,transforms<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn,optim<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> d2l<br><br>train_iter,test_iter=d2l.load_data_fashion_mnist(<span class="hljs-number">64</span>)<br><br>train_aug=transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">224</span>,<span class="hljs-number">224</span>)),<br>    transforms.RandomHorizontalFlip(),<br>    <span class="hljs-comment"># transforms.ToTensor(), #在load时已经将PIL转化为了Tensor</span><br>    transforms.Normalize([<span class="hljs-number">0.485</span>,<span class="hljs-number">0.456</span>,<span class="hljs-number">0.406</span>],[<span class="hljs-number">0.229</span>,<span class="hljs-number">0.224</span>,<span class="hljs-number">0.225</span>]),<br>    <br>])<br><br>test_aug=transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">224</span>,<span class="hljs-number">224</span>)),<br>    <span class="hljs-comment"># transforms.ToTensor(),</span><br>    transforms.Normalize([<span class="hljs-number">0.485</span>,<span class="hljs-number">0.456</span>,<span class="hljs-number">0.406</span>],[<span class="hljs-number">0.229</span>,<span class="hljs-number">0.224</span>,<span class="hljs-number">0.225</span>])<br>])<br><br><br><span class="hljs-comment"># 指定预训练模型</span><br>finetune_res=models.resnet18(pretrained=<span class="hljs-literal">True</span>,progress=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 将分类器部分重新设计，in_features属性记录了原模型的本层的输入特征数</span><br>finetune_res.fc=nn.Linear(finetune_res.fc.in_features,<span class="hljs-number">10</span>)<br><span class="hljs-comment"># 初始化新分类器参数</span><br>nn.init.xavier_uniform_(finetune_res.fc.weight)<br><br>loss_f=nn.CrossEntropyLoss()<br><span class="hljs-comment"># 增加正则化并且学习率应该设得很小</span><br>opt=optim.Adam(finetune_res.parameters(),weight_decay=<span class="hljs-number">0.1</span>,lr=<span class="hljs-number">5e-5</span>)<br><br><span class="hljs-comment"># 不需要迭代很多轮</span><br>d2l.train(<br>    <span class="hljs-number">5</span>,loss_f,opt,finetune_res,train_iter,<br>    save_name=<span class="hljs-string">"res18_pretrained"</span>,device=torch.device(<span class="hljs-string">"cuda:0"</span>),<br>    aug=train_aug<br>    )<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Fine-Tune&quot;&gt;&lt;a href=&quot;#Fine-Tune&quot; class=&quot;headerlink&quot; title=&quot;Fine Tune&quot;&gt;&lt;/a&gt;Fine Tune&lt;/h1&gt;&lt;h2 id=&quot;Concept-and-Principle&quot;&gt;&lt;a href=&quot;#Conc</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Data Augmentation</title>
    <link href="http://example.com/2022/09/15/d2l_18/"/>
    <id>http://example.com/2022/09/15/d2l_18/</id>
    <published>2022-09-15T01:45:13.995Z</published>
    <updated>2022-09-15T01:45:13.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><p>我们收集的训练数据通常很难覆盖到未来可能部署的全部场景（比如人脸识别的应用可能会部署到不同摄像头状况、天气、时间等的场景）。数据增强则在一个已有的数据上做数据变换，起到增大数据集的作用，使其有更好的多样性。</p><ul><li><p>数据增强</p><ul><li>数据增强只在训练时进行</li><li>一般采用在线生成的方式</li><li>数据增强假设测试环境中会出现增强后的数据，如果测试环境和训练集高度一致则没有必要做数据增强</li></ul></li><li><p>数据增强方法</p><ul><li>翻转（上下、左右翻转）</li><li>切割（随机高宽比、大小、位置切割一块，然后再变为固定大小）</li><li>颜色（色调、饱和度、亮度）</li><li>其他（高斯模糊、锐化、遮挡等）</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pytorch在提供transforms模块中提供了很多数据增广函数</span><br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> d2l<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_images</span>(<span class="hljs-params">imgs, num_rows, num_cols, titles=<span class="hljs-literal">None</span>, scale=<span class="hljs-number">1.5</span></span>):</span>  <br>    <br>    figsize = (num_cols * scale, num_rows * scale)<br>    _, axes = plt.subplots(num_rows, num_cols, figsize=figsize)<br>    axes = axes.flatten()<br>    <span class="hljs-keyword">for</span> i, (ax, img) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(axes, imgs)):<br>        <span class="hljs-keyword">if</span> torch.is_tensor(img):<br>            ax.imshow(transforms.ToPILImage()(img))<br>        <span class="hljs-keyword">else</span>:<br>            ax.imshow(img)<br>        ax.axes.get_xaxis().set_visible(<span class="hljs-literal">False</span>)<br>        ax.axes.get_yaxis().set_visible(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> titles:<br>            ax.set_title(titles[i])<br>    plt.show()<br>    <span class="hljs-keyword">return</span> axes<br><br>train_iter,test_iter=d2l.load_data_fashion_mnist(<span class="hljs-number">4</span>,(<span class="hljs-number">224</span>,<span class="hljs-number">224</span>))<br>X,y=<span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(test_iter))<br><br><span class="hljs-comment"># 显示tensor形式的图片</span><br><span class="hljs-comment"># X=X.view(4,224,224)</span><br><br>show_images(X,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,scale=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 数据增广</span><br><span class="hljs-comment"># trans=transforms.RandomCrop((20,20))</span><br><span class="hljs-comment"># trans=transforms.RandomHorizontalFlip()</span><br><span class="hljs-comment"># trans=transforms.GaussianBlur(5)</span><br>trans=transforms.RandomErasing(<span class="hljs-number">1</span>)<br>show_images(trans(X),<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,scale=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 显示使用PIL读进内存的图片</span><br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>test_data=torchvision.datasets.FashionMNIST(<br>        root=<span class="hljs-string">"./dataset"</span>,train=<span class="hljs-literal">False</span>,<br>        download=<span class="hljs-literal">True</span>,transform=transforms.ToTensor()<br>    )<br><br><span class="hljs-built_in">print</span>(test_data[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].shape)<br><span class="hljs-comment"># 将Tensor形式转换为PIL形式</span><br>image=transforms.ToPILImage()(test_data[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>image.show()<br><span class="hljs-keyword">import</span> torchvision<br>test_data=torchvision.datasets.FashionMNIST(<br>        root=<span class="hljs-string">"./dataset"</span>,train=<span class="hljs-literal">False</span>,<br>        download=<span class="hljs-literal">True</span><br>    )<br><span class="hljs-comment"># 第i张图片test_data[i][0]，test_data[i][1]是第一张图片的标签</span><br>d2l.show_images([test_data[i][<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)], <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, scale=<span class="hljs-number">0.8</span>)<br><br>image = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">r"./1.jpg"</span>)<br><span class="hljs-built_in">print</span>(image)<br><span class="hljs-comment"># 将PIL形式转换为Tensor形式</span><br><span class="hljs-built_in">print</span>(transforms.ToTensor()(image))<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Data-Augmentation&quot;&gt;&lt;a href=&quot;#Data-Augmentation&quot; class=&quot;headerlink&quot; title=&quot;Data Augmentation&quot;&gt;&lt;/a&gt;Data Augmentation&lt;/h1&gt;&lt;h2 id=&quot;Conce</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>D2L: ResNet</title>
    <link href="http://example.com/2022/09/15/d2l_17/"/>
    <id>http://example.com/2022/09/15/d2l_17/</id>
    <published>2022-09-15T01:45:10.964Z</published>
    <updated>2022-09-15T01:45:10.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><ul><li><p>加更多的层不一定总是改进精度</p><ul><li>新的层可能是使模型收敛范围偏差到一个不符合预期的区域</li><li>ResNet使各层更容易学会恒等变换，从而更容易使模型收敛范围达到Nested function classes<br><img src="/images/d2l/17/1.png"></li></ul></li><li><p>残差块</p><ul><li>基本的ResBlock结构如下，f(x)+x保证了包含原收敛范围<br><br><img src="/images/d2l/17/2.png"></li><li>具体使用时，ResBlock的设计细节<br><br><img src="/images/d2l/17/4.png"></li></ul></li><li><p>ResNet架构<br>一般来说现在的主流设计架构就是接入一个Stage（7x7Conv-3x3MP），之后再连接具体想要的网络架构，ResNet架构如下也是这种设计思想，具体架构如下<br>  <img src="/images/d2l/17/5.png"></p></li></ul><ul><li>Tricks<ul><li>实际应用中，Res34用的最多，达不到要求可以继续用Res50</li><li>Res152、Res101一般用来刷榜</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn,optim<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> d2l<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Residual</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        self,in_channels,out_channels,</span></span><br><span class="hljs-params"><span class="hljs-function">        use_1x1conv=<span class="hljs-literal">False</span>,stride=<span class="hljs-number">1</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1=nn.Conv2d(in_channels,out_channels,<span class="hljs-number">3</span>,stride,<span class="hljs-number">1</span>)<br>        self.conv2=nn.Conv2d(out_channels,out_channels,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.bn1=nn.BatchNorm2d(out_channels)<br>        self.bn2=nn.BatchNorm2d(out_channels)<br>        <span class="hljs-comment"># inplace更省内存(显存)</span><br>        self.relu=nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        self.conv3=<span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span>(use_1x1conv):<br>            self.conv3=nn.Conv2d(in_channels,out_channels,<span class="hljs-number">1</span>,stride)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self,X</span>):</span><br>        Y=self.relu(self.bn1(self.conv1(X)))<br>        Y=self.bn2(self.conv2(Y))<br><br>        <span class="hljs-keyword">if</span>(self.conv3):<br>            X=self.conv3(X)<br>        <span class="hljs-keyword">return</span> self.relu(Y+X)<br><br>s1=nn.Sequential(nn.Conv2d(<span class="hljs-number">1</span>,<span class="hljs-number">64</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),nn.BatchNorm2d(<span class="hljs-number">64</span>),nn.ReLU(),nn.MaxPool2d(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resnet_block</span>(<span class="hljs-params">input_channels, num_channels, num_residuals,</span></span><br><span class="hljs-params"><span class="hljs-function">                 first_block=<span class="hljs-literal">False</span></span>):</span><br>    blk = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_residuals):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> first_block:<br>            blk.append(<br>                Residual(input_channels, num_channels, use_1x1conv=<span class="hljs-literal">True</span>,<br>                         stride=<span class="hljs-number">2</span>))<br>        <span class="hljs-keyword">else</span>:<br>            blk.append(Residual(num_channels, num_channels))<br>    <span class="hljs-keyword">return</span> blk<br><br>s2=nn.Sequential(*resnet_block(<span class="hljs-number">64</span>,<span class="hljs-number">64</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">True</span>))<br>s3=nn.Sequential(*resnet_block(<span class="hljs-number">64</span>,<span class="hljs-number">128</span>,<span class="hljs-number">2</span>))<br>s4=nn.Sequential(*resnet_block(<span class="hljs-number">128</span>,<span class="hljs-number">256</span>,<span class="hljs-number">2</span>))<br>s5=nn.Sequential(*resnet_block(<span class="hljs-number">256</span>,<span class="hljs-number">512</span>,<span class="hljs-number">2</span>))<br><br>device=torch.device(<span class="hljs-string">"cuda:0"</span>)<br>res_net=nn.Sequential(<br>    s1,s2,s3,s4,s5,<br>    nn.AdaptiveAvgPool2d((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)),<br>    nn.Flatten(),<br>    nn.Linear(<span class="hljs-number">512</span>,<span class="hljs-number">10</span>)<br>)<br><br>x=torch.rand((<span class="hljs-number">20</span>,<span class="hljs-number">1</span>,<span class="hljs-number">224</span>,<span class="hljs-number">224</span>))<br><span class="hljs-built_in">print</span>(res_net(x).shape)<br><br>opt=optim.Adam(res_net.parameters())<br>train_iter,val_iter=d2l.load_data_fashion_mnist(<span class="hljs-number">128</span>,(<span class="hljs-number">224</span>,<span class="hljs-number">224</span>))<br><br><span class="hljs-comment"># d2l.train(</span><br><span class="hljs-comment">#     10,nn.CrossEntropyLoss(),opt,</span><br><span class="hljs-comment">#     res_net,train_iter,save_name="res_net"</span><br><span class="hljs-comment">#     )</span><br><br>d2l.evaluate(res_net,val_iter,nn.CrossEntropyLoss(),<span class="hljs-string">"./params/res_net_2"</span>,device=torch.device(<span class="hljs-string">"cuda:0"</span>))<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ResNet&quot;&gt;&lt;a href=&quot;#ResNet&quot; class=&quot;headerlink&quot; title=&quot;ResNet&quot;&gt;&lt;/a&gt;ResNet&lt;/h1&gt;&lt;h2 id=&quot;Concept-and-Principle&quot;&gt;&lt;a href=&quot;#Concept-and-Prin</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Batch Normalization</title>
    <link href="http://example.com/2022/09/15/d2l_16/"/>
    <id>http://example.com/2022/09/15/d2l_16/</id>
    <published>2022-09-15T01:45:08.398Z</published>
    <updated>2022-09-15T01:45:08.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><ul><li>问题<ul><li>损失出现在最后，由BP算法和梯度消失，后面的层训练的会更快</li><li>数据在最前面，前面的层训练的慢且前面的层变化后面的层也要跟着变（抽取的底层信息变化让后面的层要重新学），所以后面的层要重新学习很多次，导致收敛变慢</li><li>考虑在学习底部层时避免变化顶部层</li></ul></li><li>批量归一化<ul><li>固定小批量里面的均值和方差，然后再做额外的调整（可学习的参数gama和beta）<br><img src="/images/d2l/16/1.png"></li><li>是线性变换</li><li>作用在<ul><li>全连接层和卷积层输出后，激活函数前</li><li>全连接层和卷积层输入前</li></ul></li><li>对于全连接层作用于特征维</li><li>对于卷积层作用于通道维（将每一个像素都当作一个样本，通道数就是一个样本的特征数）</li></ul></li><li>批量归一化在做什么？<ul><li>最初的论文是想用它来减少内部协变量转移（使每一层的输出分布变化不那么剧烈）</li><li>后续有论文指出，批量归一化可能只是在小批量中加入噪声控制模型复杂度</li></ul></li><li>总结<ul><li>批量归一化固定小批量中的均值和方差，然后学习出适合的偏移和缩放</li><li>批量归一化可以加速收敛（可以设置更大的学习率），一般不改变模型精度</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn,optim<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch<br><br>net=nn.Sequential(<br>    nn.Conv2d(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,kernel_size=<span class="hljs-number">5</span>,padding=<span class="hljs-number">2</span>),nn.BatchNorm2d(<span class="hljs-number">6</span>),<br>    nn.AvgPool2d(<span class="hljs-number">2</span>),nn.Sigmoid(),<br>    nn.Conv2d(<span class="hljs-number">6</span>,<span class="hljs-number">16</span>,<span class="hljs-number">5</span>),nn.BatchNorm2d(<span class="hljs-number">16</span>),<br>    nn.AvgPool2d(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),nn.Sigmoid(),nn.Flatten(),<br>    nn.Linear(<span class="hljs-number">16</span>*<span class="hljs-number">5</span>*<span class="hljs-number">5</span>,<span class="hljs-number">120</span>),nn.BatchNorm1d(<span class="hljs-number">120</span>),<br>    nn.Sigmoid(),<br>    nn.Linear(<span class="hljs-number">120</span>,<span class="hljs-number">84</span>),nn.BatchNorm1d(<span class="hljs-number">84</span>),<br>    nn.Sigmoid(),<br>    nn.Linear(<span class="hljs-number">84</span>,<span class="hljs-number">10</span>)<br>)<br>loss_f=nn.CrossEntropyLoss()<br>opt=optim.Adam(net.parameters(),lr=<span class="hljs-number">1.0</span>)<br><br><span class="hljs-keyword">import</span> d2l<br><br><br>train_iter,test_iter=d2l.load_data_fashion_mnist(<span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># d2l.train(</span><br><span class="hljs-comment">#     10,nn.CrossEntropyLoss(),</span><br><span class="hljs-comment">#     optim.Adam(net.parameters()),</span><br><span class="hljs-comment">#     net,train_iter,save_name="LeNet_bn",</span><br><span class="hljs-comment">#     device=torch.device("cuda:0"))</span><br>d2l.evaluate(<br>    net,test_iter,nn.CrossEntropyLoss(),<br>    param_path=<span class="hljs-string">"D:/code/machine_learning/limu_d2l/params/LeNet_bn_10"</span>,<br>    device=torch.device(<span class="hljs-string">"cuda:0"</span>)<br>)<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Batch-Normalization&quot;&gt;&lt;a href=&quot;#Batch-Normalization&quot; class=&quot;headerlink&quot; title=&quot;Batch Normalization&quot;&gt;&lt;/a&gt;Batch Normalization&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>D2L: GoogLeNet</title>
    <link href="http://example.com/2022/09/15/d2l_15/"/>
    <id>http://example.com/2022/09/15/d2l_15/</id>
    <published>2022-09-15T01:45:05.900Z</published>
    <updated>2022-09-15T01:45:05.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><ul><li>Inception块<ul><li>4个路径从不同层面抽取信息，然后再输出通道合并，最终输出高宽与输入相等，要把更多的通道数留给比较重要的通道<br><img src="/images/d2l/15/1.png"></li><li>要达到相同的输出通道数，Inception块与直接的3x3或5x5卷积相比，参数和计算复杂度更低</li></ul></li><li>GoogLeNet<ul><li>5个stage（高宽减半一次就是一个stage），9个Inception块<br><img src="/images/d2l/15/2.png"></li></ul></li><li>Inception后续具有多个变种<ul><li>Inception-BN(v2)：使用batch normalization</li><li>Inception-v3：修改了inception块</li><li>Inception-v4：使用了残差连接</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn,optim<br><span class="hljs-keyword">import</span> d2l<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inception</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, c1, c2, c3, c4, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>(Inception, self).__init__(**kwargs)<br>        self.p1_1 = nn.Conv2d(in_channels, c1, kernel_size=<span class="hljs-number">1</span>)<br>        self.p2_1 = nn.Conv2d(in_channels, c2[<span class="hljs-number">0</span>], kernel_size=<span class="hljs-number">1</span>)<br>        self.p2_2 = nn.Conv2d(c2[<span class="hljs-number">0</span>], c2[<span class="hljs-number">1</span>], kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.p3_1 = nn.Conv2d(in_channels, c3[<span class="hljs-number">0</span>], kernel_size=<span class="hljs-number">1</span>)<br>        self.p3_2 = nn.Conv2d(c3[<span class="hljs-number">0</span>], c3[<span class="hljs-number">1</span>], kernel_size=<span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        self.p4_1 = nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)<br>        self.p4_2 = nn.Conv2d(in_channels, c4, kernel_size=<span class="hljs-number">1</span>)<br><br>        self.relu=nn.ReLU()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        p1 = self.relu(self.p1_1(x))<br>        p2 = self.relu(self.p2_2(self.relu(self.p2_1(x))))<br>        p3 = self.relu(self.p3_2(self.relu(self.p3_1(x))))<br>        p4 = self.relu(self.p4_2(self.p4_1(x)))<br>        <span class="hljs-comment"># 以通道维拼接张量</span><br>        <span class="hljs-keyword">return</span> torch.cat((p1, p2, p3, p4), dim=<span class="hljs-number">1</span>)<br><br>b1 = nn.Sequential(nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">7</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">3</span>),<br>                   nn.ReLU(), nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>,<br>                                           padding=<span class="hljs-number">1</span>))<br><br>b2 = nn.Sequential(nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">1</span>), nn.ReLU(),<br>                   nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">192</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br><br>b3 = nn.Sequential(Inception(<span class="hljs-number">192</span>, <span class="hljs-number">64</span>, (<span class="hljs-number">96</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">16</span>, <span class="hljs-number">32</span>), <span class="hljs-number">32</span>),<br>                   Inception(<span class="hljs-number">256</span>, <span class="hljs-number">128</span>, (<span class="hljs-number">128</span>, <span class="hljs-number">192</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">96</span>), <span class="hljs-number">64</span>),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br><br>b4 = nn.Sequential(Inception(<span class="hljs-number">480</span>, <span class="hljs-number">192</span>, (<span class="hljs-number">96</span>, <span class="hljs-number">208</span>), (<span class="hljs-number">16</span>, <span class="hljs-number">48</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">512</span>, <span class="hljs-number">160</span>, (<span class="hljs-number">112</span>, <span class="hljs-number">224</span>), (<span class="hljs-number">24</span>, <span class="hljs-number">64</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">512</span>, <span class="hljs-number">128</span>, (<span class="hljs-number">128</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">24</span>, <span class="hljs-number">64</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">512</span>, <span class="hljs-number">112</span>, (<span class="hljs-number">144</span>, <span class="hljs-number">288</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">64</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">528</span>, <span class="hljs-number">256</span>, (<span class="hljs-number">160</span>, <span class="hljs-number">320</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">128</span>), <span class="hljs-number">128</span>),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br><br>b5 = nn.Sequential(Inception(<span class="hljs-number">832</span>, <span class="hljs-number">256</span>, (<span class="hljs-number">160</span>, <span class="hljs-number">320</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">128</span>), <span class="hljs-number">128</span>),<br>                   Inception(<span class="hljs-number">832</span>, <span class="hljs-number">384</span>, (<span class="hljs-number">192</span>, <span class="hljs-number">384</span>), (<span class="hljs-number">48</span>, <span class="hljs-number">128</span>), <span class="hljs-number">128</span>),<br>                   nn.AdaptiveAvgPool2d((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), nn.Flatten())<br><br>net = nn.Sequential(b1, b2, b3, b4, b5, nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">10</span>))<br><br>loss_f=nn.CrossEntropyLoss()<br>opt=optim.Adam(net.parameters())<br>train_iter,test_iter=d2l.load_data_fashion_mnist(<span class="hljs-number">128</span>,resize=<span class="hljs-number">96</span>)<br><br><span class="hljs-comment"># d2l.train(</span><br><span class="hljs-comment">#     10,loss_f,opt,net,train_iter,</span><br><span class="hljs-comment">#     device=torch.device("cuda:0"),</span><br><span class="hljs-comment">#     save_name="GoogLeNet"</span><br><span class="hljs-comment"># )</span><br><br>d2l.evaluate(<br>    net,test_iter,loss_f,<br>    <span class="hljs-string">"D:/code/machine_learning/limu_d2l/params/GoogLeNet_5"</span>,<br>    device=torch.device(<span class="hljs-string">"cuda:0"</span>)<br>)<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GoogLeNet&quot;&gt;&lt;a href=&quot;#GoogLeNet&quot; class=&quot;headerlink&quot; title=&quot;GoogLeNet&quot;&gt;&lt;/a&gt;GoogLeNet&lt;/h1&gt;&lt;h2 id=&quot;Concept-and-Principle&quot;&gt;&lt;a href=&quot;#Conc</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>D2L: NiN</title>
    <link href="http://example.com/2022/09/15/d2l_14/"/>
    <id>http://example.com/2022/09/15/d2l_14/</id>
    <published>2022-09-15T01:45:03.519Z</published>
    <updated>2022-09-15T01:45:03.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NiN"><a href="#NiN" class="headerlink" title="NiN"></a>NiN</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><ul><li>全连接层的问题：<ul><li>全连接层参数比卷积层的参数多很多，导致很多的内存（显存）及计算带宽占用</li><li>全连接层容易带来过拟合</li></ul></li><li>NiN思想：完全不要全连接层</li><li>NiN块：<ul><li>一个卷积层后跟两个起到全连接层的作用的卷积层</li><li>起到全连接层的作用的卷积层为1x1步幅为1无填充的卷积层</li></ul></li><li>NiN架构<ul><li>无全连接层</li><li>交替使用NiN块和步幅为2的最大池化层</li><li>最后使用全局平均池化层得到输出（通道数是类别数）<br><img src="/images/d2l/14/1.png"></li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn,optim<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NiNBlock</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        self,in_channels,out_channels,</span></span><br><span class="hljs-params"><span class="hljs-function">        kernel_size,stride,padding</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv=nn.Conv2d(<br>            in_channels,out_channels,kernel_size,<br>            stride=stride,padding=padding<br>        )<br>        self.f1=nn.Conv2d(out_channels,out_channels,<span class="hljs-number">1</span>)<br>        self.f2=nn.Conv2d(out_channels,out_channels,<span class="hljs-number">1</span>)<br>        self.relu=nn.ReLU()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self,x</span>):</span><br>        x=self.relu(self.conv(x))<br>        x=self.relu(self.f1(x))<br>        x=self.relu(self.f2(x))<br>        <span class="hljs-keyword">return</span> x<br><br>nin_net=nn.Sequential(<br>    NiNBlock(<span class="hljs-number">1</span>,<span class="hljs-number">96</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>),<br>    nn.MaxPool2d(<span class="hljs-number">3</span>,stride=<span class="hljs-number">2</span>),<br>    NiNBlock(<span class="hljs-number">96</span>,<span class="hljs-number">256</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<br>    nn.MaxPool2d(<span class="hljs-number">3</span>,stride=<span class="hljs-number">2</span>),<br>    NiNBlock(<span class="hljs-number">256</span>,<span class="hljs-number">384</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br>    nn.MaxPool2d(<span class="hljs-number">3</span>,stride=<span class="hljs-number">2</span>),nn.Dropout(),<br>    NiNBlock(<span class="hljs-number">384</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br>    <span class="hljs-comment"># 目标输出size为1x1，也就是全局池化</span><br>    nn.AdaptiveAvgPool2d(<span class="hljs-number">1</span>),<br>    nn.Flatten()<br>)<br><br>loss_f=nn.CrossEntropyLoss()<br>opt=optim.Adam(nin_net.parameters())<br><br><span class="hljs-keyword">import</span> d2l<br><br>train_iter,test_iter=d2l.load_data_fashion_mnist(<span class="hljs-number">128</span>,resize=<span class="hljs-number">224</span>)<br><br><span class="hljs-comment"># d2l.train(</span><br><span class="hljs-comment">#     10,loss_f,opt,nin_net,train_iter,</span><br><span class="hljs-comment">#     device=torch.device("cuda:0"),</span><br><span class="hljs-comment">#     save_name="NIN"</span><br><span class="hljs-comment"># )</span><br>d2l.evaluate(<br>    nin_net,test_iter,loss_f,<br>    <span class="hljs-string">"D:/code/machine_learning/limu_d2l/params/NIN_5"</span>,<br>    device=torch.device(<span class="hljs-string">"cuda:0"</span>)<br>)<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NiN&quot;&gt;&lt;a href=&quot;#NiN&quot; class=&quot;headerlink&quot; title=&quot;NiN&quot;&gt;&lt;/a&gt;NiN&lt;/h1&gt;&lt;h2 id=&quot;Concept-and-Principle&quot;&gt;&lt;a href=&quot;#Concept-and-Principle&quot; class</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>D2L: VGGNet</title>
    <link href="http://example.com/2022/09/15/d2l_13/"/>
    <id>http://example.com/2022/09/15/d2l_13/</id>
    <published>2022-09-15T01:45:00.927Z</published>
    <updated>2022-09-15T01:45:00.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VGGNet"><a href="#VGGNet" class="headerlink" title="VGGNet"></a>VGGNet</h1><h2 id="Concept-and-Principle"><a href="#Concept-and-Principle" class="headerlink" title="Concept and Principle"></a><strong>Concept and Principle</strong></h2><ul><li>AlexNet的设计很随意，如何变大变深无规律性，VGG探讨了如何对CNN进行扩展</li><li>如何更深更大？<ul><li>更多全连接层（太贵）</li><li>更多的卷积层</li><li>将卷积层组合成块（VGG）</li></ul></li><li>VGG块<ul><li>使用小卷积核深网络比大小卷积核浅网络效果好</li><li>3x3卷积层（n层、m通道）</li><li>2x2最大池化层<br><img src="/images/d2l/13/2.png"></li></ul></li><li>VGG架构<ul><li>多个VGG块后接全连接层</li><li>不同次数的重复块得到不同架构（VGG-16、VGG-19等）<br><img src="/images/d2l/13/1.png"></li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> dropout, nn,optim<br><span class="hljs-keyword">import</span> d2l<br><span class="hljs-comment"># 返回VGG块</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vgg_block</span>(<span class="hljs-params">num_convs,in_channels,out_channels</span>):</span><br>    layers=[]<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layers.append(<br>            nn.Conv2d(in_channels,out_channels,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>            )<br>        layers.append(nn.ReLU())<br>        in_channels=out_channels<br><br>    layers.append(nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>))<br>    <br>    <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vgg_architecture</span>(<span class="hljs-params">num_blocks,in_channels</span>):</span><br>    blocks=[]<br>    out_channels=<span class="hljs-number">16</span><br>    blocks.append(vgg_block(<span class="hljs-number">1</span>,in_channels,out_channels))<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_blocks-<span class="hljs-number">1</span>):<br>        in_channels=out_channels<br>        out_channels*=<span class="hljs-number">2</span><br>        blocks.append(vgg_block(<span class="hljs-number">1</span>,in_channels,out_channels))<br>    <br>    <span class="hljs-keyword">return</span> nn.Sequential(*blocks)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vgg_5</span>(<span class="hljs-params">in_channels</span>):</span><br>    <span class="hljs-keyword">return</span> nn.Sequential(<br>        vgg_architecture(<span class="hljs-number">5</span>,in_channels),<br>        nn.Flatten(),<br>        nn.Linear(<span class="hljs-number">256</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>,<span class="hljs-number">1024</span>),<br>        nn.Dropout(),<br>        nn.Linear(<span class="hljs-number">1024</span>,<span class="hljs-number">512</span>),<br>        nn.Dropout(),<br>        nn.Linear(<span class="hljs-number">512</span>,<span class="hljs-number">10</span>)<br>    )<br><br>vgg=vgg_5(<span class="hljs-number">1</span>).to(torch.device(<span class="hljs-string">"cuda:0"</span>))<br><br>train_iter,test_iter=d2l.load_data_fashion_mnist(<span class="hljs-number">64</span>,<span class="hljs-number">224</span>)<br>loss_f=nn.CrossEntropyLoss()<br>opt=optim.Adam(vgg.parameters())<br><br>d2l.train(<span class="hljs-number">10</span>,loss_f,opt,vgg,train_iter,save_name=<span class="hljs-string">"vgg_5"</span>)<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VGGNet&quot;&gt;&lt;a href=&quot;#VGGNet&quot; class=&quot;headerlink&quot; title=&quot;VGGNet&quot;&gt;&lt;/a&gt;VGGNet&lt;/h1&gt;&lt;h2 id=&quot;Concept-and-Principle&quot;&gt;&lt;a href=&quot;#Concept-and-Prin</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
  </entry>
  
</feed>
