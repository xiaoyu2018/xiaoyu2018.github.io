<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xavier&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-27T04:16:47.198Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Xavier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>D2L: Batch Normalization</title>
    <link href="http://example.com/2022/01/27/d2l_16/"/>
    <id>http://example.com/2022/01/27/d2l_16/</id>
    <published>2022-01-27T04:16:47.198Z</published>
    <updated>2022-01-27T04:16:47.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><ul><li>问题<ul><li>损失出现在最后，由BP算法和梯度消失，后面的层训练的会更快</li><li>数据在最前面，前面的层训练的慢且前面的层变化后面的层也要跟着变（抽取的底层信息变化让后面的层要重新学），所以后面的层要重新学习很多次，导致收敛变慢</li><li>考虑在学习底部层时避免变化顶部层</li></ul></li><li>批量归一化<ul><li>固定小批量里面的均值和方差，然后再做额外的调整（可学习的参数gama和beta）<br><img src="/images/d2l/16/1.png"></li><li>是线性变换</li><li>作用在<ul><li>全连接层和卷积层输出后，激活函数前</li><li>全连接层和卷积层输入前</li></ul></li><li>对于全连接层作用于特征维</li><li>对于卷积层作用于通道维（将每一个像素都当作一个样本，通道数就是一个样本的特征数）</li></ul></li><li>批量归一化在做什么？<ul><li>最初的论文是想用它来减少内部协变量转移（使每一层的输出分布变化不那么剧烈）</li><li>后续有论文指出，批量归一化可能只是在小批量中加入噪声控制模型复杂度</li></ul></li><li>总结<ul><li>批量归一化固定小批量中的均值和方差，然后学习出适合的偏移和缩放</li><li>批量归一化可以加速收敛（可以设置更大的学习率），一般不改变模型精度<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2></li></ul></li></ul><pre><code class="python">from torch import nn,optimimport torchimport torchnet=nn.Sequential(    nn.Conv2d(1,6,kernel_size=5,padding=2),nn.BatchNorm2d(6),    nn.AvgPool2d(2),nn.Sigmoid(),    nn.Conv2d(6,16,5),nn.BatchNorm2d(16),    nn.AvgPool2d(2,2),nn.Sigmoid(),nn.Flatten(),    nn.Linear(16*5*5,120),nn.BatchNorm1d(120),    nn.Sigmoid(),    nn.Linear(120,84),nn.BatchNorm1d(84),    nn.Sigmoid(),    nn.Linear(84,10))loss_f=nn.CrossEntropyLoss()opt=optim.Adam(net.parameters(),lr=1.0)import d2ltrain_iter,test_iter=d2l.load_data_fashion_mnist(256)# d2l.train(#     10,nn.CrossEntropyLoss(),#     optim.Adam(net.parameters()),#     net,train_iter,save_name="LeNet_bn",#     device=torch.device("cuda:0"))d2l.evaluate(    net,test_iter,nn.CrossEntropyLoss(),    param_path="D:/code/machine_learning/limu_d2l/params/LeNet_bn_10",    device=torch.device("cuda:0"))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Batch-Normalization&quot;&gt;&lt;a href=&quot;#Batch-Normalization&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: GoogLeNet</title>
    <link href="http://example.com/2022/01/25/d2l_15/"/>
    <id>http://example.com/2022/01/25/d2l_15/</id>
    <published>2022-01-25T03:46:56.930Z</published>
    <updated>2022-01-25T03:46:56.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><ul><li>Inception块<ul><li>4个路径从不同层面抽取信息，然后再输出通道合并，最终输出高宽与输入相等，要把更多的通道数留给比较重要的通道<br><img src="/images/d2l/15/1.png"></li><li>要达到相同的输出通道数，Inception块与直接的3x3或5x5卷积相比，参数和计算复杂度更低</li></ul></li><li>GoogLeNet<ul><li>5个stage（高宽减半一次就是一个stage），9个Inception块<br><img src="/images/d2l/15/2.png"></li></ul></li><li>Inception后续具有多个变种<ul><li>Inception-BN(v2)：使用batch normalization</li><li>Inception-v3：修改了inception块</li><li>Inception-v4：使用了残差连接</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><pre><code class="python">import torchfrom torch import nn,optimimport d2lclass Inception(nn.Module):    def __init__(self, in_channels, c1, c2, c3, c4, **kwargs):        super(Inception, self).__init__(**kwargs)        self.p1_1 = nn.Conv2d(in_channels, c1, kernel_size=1)        self.p2_1 = nn.Conv2d(in_channels, c2[0], kernel_size=1)        self.p2_2 = nn.Conv2d(c2[0], c2[1], kernel_size=3, padding=1)        self.p3_1 = nn.Conv2d(in_channels, c3[0], kernel_size=1)        self.p3_2 = nn.Conv2d(c3[0], c3[1], kernel_size=5, padding=2)        self.p4_1 = nn.MaxPool2d(kernel_size=3, stride=1, padding=1)        self.p4_2 = nn.Conv2d(in_channels, c4, kernel_size=1)        self.relu=nn.ReLU()    def forward(self, x):        p1 = self.relu(self.p1_1(x))        p2 = self.relu(self.p2_2(self.relu(self.p2_1(x))))        p3 = self.relu(self.p3_2(self.relu(self.p3_1(x))))        p4 = self.relu(self.p4_2(self.p4_1(x)))        # 以通道维拼接张量        return torch.cat((p1, p2, p3, p4), dim=1)b1 = nn.Sequential(nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3),                   nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2,                                           padding=1))b2 = nn.Sequential(nn.Conv2d(64, 64, kernel_size=1), nn.ReLU(),                   nn.Conv2d(64, 192, kernel_size=3, padding=1),                   nn.MaxPool2d(kernel_size=3, stride=2, padding=1))b3 = nn.Sequential(Inception(192, 64, (96, 128), (16, 32), 32),                   Inception(256, 128, (128, 192), (32, 96), 64),                   nn.MaxPool2d(kernel_size=3, stride=2, padding=1))b4 = nn.Sequential(Inception(480, 192, (96, 208), (16, 48), 64),                   Inception(512, 160, (112, 224), (24, 64), 64),                   Inception(512, 128, (128, 256), (24, 64), 64),                   Inception(512, 112, (144, 288), (32, 64), 64),                   Inception(528, 256, (160, 320), (32, 128), 128),                   nn.MaxPool2d(kernel_size=3, stride=2, padding=1))b5 = nn.Sequential(Inception(832, 256, (160, 320), (32, 128), 128),                   Inception(832, 384, (192, 384), (48, 128), 128),                   nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten())net = nn.Sequential(b1, b2, b3, b4, b5, nn.Linear(1024, 10))loss_f=nn.CrossEntropyLoss()opt=optim.Adam(net.parameters())train_iter,test_iter=d2l.load_data_fashion_mnist(128,resize=96)# d2l.train(#     10,loss_f,opt,net,train_iter,#     device=torch.device("cuda:0"),#     save_name="GoogLeNet"# )d2l.evaluate(    net,test_iter,loss_f,    "D:/code/machine_learning/limu_d2l/params/GoogLeNet_5",    device=torch.device("cuda:0"))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;GoogLeNet&quot;&gt;&lt;a href=&quot;#GoogLeNet&quot; class=&quot;headerlink&quot; title=&quot;GoogLeNet&quot;&gt;&lt;/a&gt;Goo</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: NiN</title>
    <link href="http://example.com/2022/01/24/d2l_14/"/>
    <id>http://example.com/2022/01/24/d2l_14/</id>
    <published>2022-01-24T08:13:02.319Z</published>
    <updated>2022-01-24T08:13:02.319Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="NiN"><a href="#NiN" class="headerlink" title="NiN"></a>NiN</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><ul><li>全连接层的问题：<ul><li>全连接层参数比卷积层的参数多很多，导致很多的内存（显存）及计算带宽占用</li><li>全连接层容易带来过拟合</li></ul></li><li>NiN思想：完全不要全连接层</li><li>NiN块：<ul><li>一个卷积层后跟两个起到全连接层的作用的卷积层</li><li>起到全连接层的作用的卷积层为1x1步幅为1无填充的卷积层</li></ul></li><li>NiN架构<ul><li>无全连接层</li><li>交替使用NiN块和步幅为2的最大池化层</li><li>最后使用全局平均池化层得到输出（通道数是类别数）<br><img src="/images/d2l/14/1.png"></li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><pre><code class="python">import torchfrom torch import nn,optimclass NiNBlock(nn.Module):    def __init__(        self,in_channels,out_channels,        kernel_size,stride,padding    ):        super().__init__()        self.conv=nn.Conv2d(            in_channels,out_channels,kernel_size,            stride=stride,padding=padding        )        self.f1=nn.Conv2d(out_channels,out_channels,1)        self.f2=nn.Conv2d(out_channels,out_channels,1)        self.relu=nn.ReLU()    def forward(self,x):        x=self.relu(self.conv(x))        x=self.relu(self.f1(x))        x=self.relu(self.f2(x))        return xnin_net=nn.Sequential(    NiNBlock(1,96,11,4,0),    nn.MaxPool2d(3,stride=2),    NiNBlock(96,256,5,1,2),    nn.MaxPool2d(3,stride=2),    NiNBlock(256,384,3,1,1),    nn.MaxPool2d(3,stride=2),nn.Dropout(),    NiNBlock(384,10,3,1,1),    # 目标输出size为1x1，也就是全局池化    nn.AdaptiveAvgPool2d(1),    nn.Flatten())loss_f=nn.CrossEntropyLoss()opt=optim.Adam(nin_net.parameters())import d2ltrain_iter,test_iter=d2l.load_data_fashion_mnist(128,resize=224)# d2l.train(#     10,loss_f,opt,nin_net,train_iter,#     device=torch.device("cuda:0"),#     save_name="NIN"# )d2l.evaluate(    nin_net,test_iter,loss_f,    "D:/code/machine_learning/limu_d2l/params/NIN_5",    device=torch.device("cuda:0"))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;NiN&quot;&gt;&lt;a href=&quot;#NiN&quot; class=&quot;headerlink&quot; title=&quot;NiN&quot;&gt;&lt;/a&gt;NiN&lt;/h1&gt;&lt;h2 id=&quot;Basic</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: VGGNet</title>
    <link href="http://example.com/2022/01/23/d2l_13/"/>
    <id>http://example.com/2022/01/23/d2l_13/</id>
    <published>2022-01-23T02:58:52.194Z</published>
    <updated>2022-01-23T02:58:52.194Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="VGGNet"><a href="#VGGNet" class="headerlink" title="VGGNet"></a>VGGNet</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><ul><li>AlexNet的设计很随意，如何变大变深无规律性，VGG探讨了如何对CNN进行扩展</li><li>如何更深更大？<ul><li>更多全连接层（太贵）</li><li>更多的卷积层</li><li>将卷积层组合成块（VGG）</li></ul></li><li>VGG块<ul><li>使用小卷积核深网络比大小卷积核浅网络效果好</li><li>3x3卷积层（n层、m通道）</li><li>2x2最大池化层<br><img src="/images/d2l/13/2.png"></li></ul></li><li>VGG架构<ul><li>多个VGG块后接全连接层</li><li>不同次数的重复块得到不同架构（VGG-16、VGG-19等）<br><img src="/images/d2l/13/1.png"></li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><pre><code class="python">import torchfrom torch import dropout, nn,optimimport d2l# 返回VGG块def vgg_block(num_convs,in_channels,out_channels):    layers=[]    for _ in range(num_convs):        layers.append(            nn.Conv2d(in_channels,out_channels,3,padding=1)            )        layers.append(nn.ReLU())        in_channels=out_channels    layers.append(nn.MaxPool2d(kernel_size=2,stride=2))        return nn.Sequential(*layers)def vgg_architecture(num_blocks,in_channels):    blocks=[]    out_channels=16    blocks.append(vgg_block(1,in_channels,out_channels))    for _ in range(num_blocks-1):        in_channels=out_channels        out_channels*=2        blocks.append(vgg_block(1,in_channels,out_channels))        return nn.Sequential(*blocks)def vgg_5(in_channels):    return nn.Sequential(        vgg_architecture(5,in_channels),        nn.Flatten(),        nn.Linear(256*7*7,1024),        nn.Dropout(),        nn.Linear(1024,512),        nn.Dropout(),        nn.Linear(512,10)    )vgg=vgg_5(1).to(torch.device("cuda:0"))train_iter,test_iter=d2l.load_data_fashion_mnist(64,224)loss_f=nn.CrossEntropyLoss()opt=optim.Adam(vgg.parameters())d2l.train(10,loss_f,opt,vgg,train_iter,save_name="vgg_5")</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;VGGNet&quot;&gt;&lt;a href=&quot;#VGGNet&quot; class=&quot;headerlink&quot; title=&quot;VGGNet&quot;&gt;&lt;/a&gt;VGGNet&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: AlexNet</title>
    <link href="http://example.com/2022/01/22/d2l_12/"/>
    <id>http://example.com/2022/01/22/d2l_12/</id>
    <published>2022-01-22T08:05:31.808Z</published>
    <updated>2022-01-22T08:05:31.808Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><ul><li>在深度学习之前：<ul><li>核方法<ul><li>特征提取</li><li>选择核函数</li><li>凸优化问题</li><li>漂亮的定理</li></ul></li><li>几何学<ul><li>抽取特征</li><li>将计算机视觉问题描述为几何问题（如多相机）</li><li>凸优化</li><li>漂亮的定理</li><li>建立假设模型，若假设满足，效果会很好</li></ul></li><li>特征工程<ul><li>特征工程（人工特征提取）是关键，不太关心机器学习模型</li><li>特征描述子（SIFT、SURF）</li><li>视觉词袋（聚类）</li><li>最后一般用SVM</li></ul></li></ul></li><li>AlexNet赢得了2012年ImageNet竞赛的冠军，引起了深度学习的热潮，其本质上是一个更深更大的LeNet<ul><li>主要改进：<ul><li>丢弃法</li><li>ReLU</li><li>MaxPooling</li><li>数据增强（截取、调亮度、调色温等）</li><li>更深更大</li></ul></li></ul></li><li>网络结构与复杂度<br><img src="/images/d2l/12/1.png"></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><pre><code class="python">import torchfrom torch import nn,optimimport d2lclass AlexNet(nn.Module):        def __init__(self):        super().__init__()        self.conv1=nn.Conv2d(1,96,kernel_size=11,stride=4,padding=1)        self.conv2=nn.Conv2d(96,256,kernel_size=5,padding=2)        self.conv3=nn.Conv2d(256,384,kernel_size=3,padding=1)        self.conv4=nn.Conv2d(384,384,kernel_size=3,padding=1)        self.conv5=nn.Conv2d(384,256,kernel_size=3,padding=1)        self.liner1=nn.Linear(6400,4096)        self.liner2=nn.Linear(4096,4096)        self.liner3=nn.Linear(4096,10)        self.pool=nn.MaxPool2d(kernel_size=3,stride=2)        self.flatten=nn.Flatten()        self.relu=nn.ReLU()        self.dropout=nn.Dropout(p=0.5)        def forward(self,x):                x=self.relu(self.pool(self.conv1(x)))                x=self.relu(self.pool(self.conv2(x)))        x=self.relu(self.conv3(x))        x=self.relu(self.conv4(x))        x=self.relu(self.conv5(x))        x=self.pool(x)        x=self.flatten(x)        x=self.dropout((self.liner1(x)))        x=self.dropout((self.liner2(x)))        x=self.liner3(x)        return xnet=AlexNet().to(torch.device("cuda:0"))# x=torch.rand((1,1,224,224)).cuda()# print(net(x).size())# 读取Fashion-MNIST，将图片直接拉伸为224x224train_iter,test_iter=d2l.load_data_fashion_mnist(256,224)# d2l.train(#     25,nn.CrossEntropyLoss(),#     optim.Adam(net.parameters()),#     net,train_iter,save_name="AlexNet",#     device=torch.device("cuda:0"))d2l.evaluate(    net,test_iter,nn.CrossEntropyLoss(),    param_path="D:\code\machine_learning\limu_d2l\params\AlexNet_5",    device=torch.device("cuda:0"))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;AlexNet&quot;&gt;&lt;a href=&quot;#AlexNet&quot; class=&quot;headerlink&quot; title=&quot;AlexNet&quot;&gt;&lt;/a&gt;AlexNet&lt;/</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: LeNet</title>
    <link href="http://example.com/2022/01/22/d2l_11/"/>
    <id>http://example.com/2022/01/22/d2l_11/</id>
    <published>2022-01-22T04:20:12.842Z</published>
    <updated>2022-01-22T04:20:12.842Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><ul><li>最早是用于手写数字识别，识别信件上的邮政编码</li><li>网络结构<br><img src="/images/d2l/11/1.png" alt="$cover"></li><li>提出了一个数据集：MNIST<ul><li>5w个训练数据</li><li>1w个测试数据</li><li>图像大小 28x28</li><li>10类</li></ul></li><li>总结<ul><li>LeNet是早期成功的神经网络</li><li>先使用卷积层学习图片空间信息</li><li>然后使用全连接层转换到类别空间</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><pre><code class="python">from torch import optimimport torchfrom torch import nnimport d2l# 定义Reshape层class Reshape(nn.Module):        def forward(self,x):        return x.view(-1,1,28,28)net=nn.Sequential(    Reshape(),    nn.Conv2d(1,6,kernel_size=5,padding=2),    nn.AvgPool2d(2),nn.Sigmoid(),    nn.Conv2d(6,16,5),    nn.AvgPool2d(2,2),nn.Sigmoid(),nn.Flatten(),    nn.Linear(16*5*5,120),nn.Sigmoid(),    nn.Linear(120,84),nn.Sigmoid(),    nn.Linear(84,10))x=torch.rand((1,28,28),dtype=torch.float32)# 观察每一层输出的tensor尺寸for layer in net:    x=layer(x)    print(layer.__class__.__name__,':\t',x.size())# 在Fashion-MINST上的表现train_iter,test_iter=d2l.load_data_fashion_mnist(256)loss_f=nn.CrossEntropyLoss()opt=optim.Adam(net.parameters())# d2l.train(#     25,loss_f,opt,net,train_iter,#     param_name="LeNet",device=torch.device("cuda:0")#     )d2l.evaluate(net,test_iter,loss_f,".\params\LeNet_25")   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;LeNet&quot;&gt;&lt;a href=&quot;#LeNet&quot; class=&quot;headerlink&quot; title=&quot;LeNet&quot;&gt;&lt;/a&gt;LeNet&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>Vison in Transformer</title>
    <link href="http://example.com/2022/01/17/VIT/"/>
    <id>http://example.com/2022/01/17/VIT/</id>
    <published>2022-01-17T08:04:28.649Z</published>
    <updated>2022-01-17T08:04:28.649Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/VIT/cover.jpg" alt="$cover"></p><h1 id="An-Image-is-Worth-16x16-Words-Transformers-for-Image-Recognition-at-Scale"><a href="#An-Image-is-Worth-16x16-Words-Transformers-for-Image-Recognition-at-Scale" class="headerlink" title="An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale"></a>An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</h1><p>从2012年AlexNet提出以来，卷积神经网络在计算机视觉领域一直占据统治地位。而本篇论文的研究表明，拥有足够多数据进行预训练的情况下，Transformer网络架构也可以把计算机视觉问题解决的很好。更进一步来说，这篇论文的提出打破了cv和nlp之间的壁垒，在多模态领域也产生了很大影响</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a><strong>Intro</strong></h2><ul><li>将每一张图片视作由许多16x16的patch组成，每个patch当作nlp领域中的单词，一张图片便可视作一个sequence</li><li>CV领域不需要局限于CNNs的结构，纯Transformer在预训练集足够大时在图像分类任务达到了目前CNNs的SOTA，并且需要更少的计算资源</li><li>使用Transformer架构，到目前为止还未出现增加数据和模型复杂度导致性能饱和的现象</li><li>CNNs具有人为规定的两个先验信息（局部性、平移不变性），而Transformer是缺少这样的信息的，所以在数据集不够的时候时VIT比CNNs的SOTA要差一点（因为VIT需要自己去学习两个先验信息），进一步扩大数据集后，效果达到SOTA</li></ul><h2 id="Problems-and-Purposes"><a href="#Problems-and-Purposes" class="headerlink" title="Problems and Purposes"></a><strong>Problems and Purposes</strong></h2><ul><li>受Transformer在nlp领域可扩展性的成功，本文想尽量少地修改Transformer架构，将这种可扩展性带到CV领域</li><li>如何把2d的图片变成1d的序列</li><li>输入transformer的长一般为512、1024这个量级，要考虑计算性能，序列过长复杂度无法接受</li><li>本文的解决方案：将原图划分为多个16x16地patch，再将patch组成sequence，大大减小了序列长度</li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a><strong>Method</strong></h2><p><img src="/images/VIT/cover.jpg" alt="$cover"><br>将原始图片划分出多个patches，patches经过线性投射层展平为一维向量，为每个向量加入位置编码后输入Transformer Encoder。另外引入了一个额外的token（第0位向量），并以该对应的Transformer Encoder输出作为分类的依据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/VIT/cover.jpg&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;An-Image-is-Worth-16x16-Words-Transformers-for-Image-Recognition-at-Scale&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Neural Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Computer Vision" scheme="http://example.com/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Convolution and Pooling</title>
    <link href="http://example.com/2022/01/17/d2l_10/"/>
    <id>http://example.com/2022/01/17/d2l_10/</id>
    <published>2022-01-17T01:58:32.835Z</published>
    <updated>2022-01-16T03:50:01.837Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Convolution-and-Pooling"><a href="#Convolution-and-Pooling" class="headerlink" title="Convolution and Pooling"></a>Convolution and Pooling</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><ul><li><p>卷积</p><ul><li>平移不变性和局部性是在图片中寻找某种模式的原则。<ul><li>因为模式不会随着其在图片中位置改变而改变，所以一个识别器（卷积核）被设计为具有平移不变性（即参数只与输入的像素值有关，而与像素在图片的位置无关），去学习图片中的一种模式</li><li>模式与其相邻的局部相关，识别器每次仅去看图片的一部分</li><li>对全连接层使用平移不变性和局部性得到卷积层</li></ul></li></ul></li><li><p>卷积层<br><img src="/images/d2l/10/1.png"></p><ul><li>不同卷积核（值）会对图片带来不同的效果，当某种效果对任务有帮助时，网络很有可能就会学习出这种卷积核<br><img src="/images/d2l/10/2.png"></li></ul></li><li><p>填充与步幅</p><ul><li>在输入的四周加入额外的行和列以控制卷积后的输出图像大小，卷积核大小一般选奇数，能上下对称地填充图片来保证输入输出图片大小不变<br><img src="/images/d2l/10/3.png"></li><li>增大卷积步幅，快速缩小图片</li><li>总结<br><img src="/images/d2l/10/4.png"></li></ul></li><li><p>通道</p><ul><li>每个通道有自己的卷积核，输入通道不同通道的对应卷积后直接相加后再加偏置项，最后输出一个单通道</li><li>多输出通道就是多个上述操作输出的多个单通道</li><li>每个输出通道可以识别特定的模式，输入通道识别并组合（加权相加）输入中的模式</li></ul></li><li><p>池化</p><ul><li>池化层缓解卷积对位置的敏感性</li><li>池化层不学习任何参数，有最大池化、平均池化等</li><li>池化层也可以调整填充与步幅</li><li>经过池化层不会改变通道数</li></ul></li><li><p>tricks</p><ul><li>填充：一般填充就是为了使图小大小不变</li><li>步幅：一般设置为1，计算量太大时增大步幅</li><li>最终图像大小：一般为3x3、5x5、7x7</li><li>1x1卷积层：不识别空间模式，而是用来改变通道数</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Convolution-and-Pooling&quot;&gt;&lt;a href=&quot;#Convolution-and-Pooling&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>ResNet</title>
    <link href="http://example.com/2021/12/17/resnet/"/>
    <id>http://example.com/2021/12/17/resnet/</id>
    <published>2021-12-17T11:12:40.591Z</published>
    <updated>2021-12-17T11:12:40.591Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/resnet/cover.jpg" alt="$cover"></p><h1 id="Residual-Network"><a href="#Residual-Network" class="headerlink" title="Residual Network"></a>Residual Network</h1><p>深层的神经网络通常很难进行训练，本文使用了一个残差学习网络结构来训练比以往的神经网络要深得多的模型。残差网络容易训练，并且在深层神经网络中表现出来较好的准确率。</p><p><img src="/images/resnet/plain_error.png" alt="plain_error"><br>在未使用残差网络的模型中，当网络层数变多时，训练误差以及测试误差均会升高。</p><h2 id="Is-learning-better-networks-as-easy-as-stacking-more-layers"><a href="#Is-learning-better-networks-as-easy-as-stacking-more-layers" class="headerlink" title="Is learning better networks as easy as stacking more layers ?"></a><strong>Is learning better networks as easy as stacking more layers ?</strong></h2><ul><li>当网络变得特别深时，会出现梯度爆炸或梯度消失</li><li>传统的解决方法是：参数在初始化时要做的好一点，不要太大也不要太小；加入一些Batch Normalization Layers</li><li>传统的解决方法使得神经网络能够收敛，但是网络的精度却变得更差，而这并非是模型变得复杂后导致的过拟合问题，因为模型的训练误差也变高了</li><li>正常来说，如果在一个浅层的神经网络后直接加入更多的层，这些层只做identity mapping，那么这个深层神经网络的误差绝不会高于浅层的神经网络，但是传统的神经网络模型并未找到这样的解（或更好的解）</li><li>如果深层网络后面的层都是是恒等映射，那么模型就可以转化为一个浅层网络</li></ul><h2 id="Deep-residual-learning-framework"><a href="#Deep-residual-learning-framework" class="headerlink" title="Deep residual learning framework"></a><strong>Deep residual learning framework</strong></h2><ul><li>将残差块的输入与块内最后一个神经网络层的线性输出求和后在进行激活，得到残差块的输出<br><img src="/images/resnet/residual_block.png" alt="plain_error"></li><li>残差块只简单地做了shortcut connections，没有引入额外的训练参数，不会增加网络复杂度</li><li>已有的神经网络很难拟合潜在的恒等映射函数H(x) = x，但是ResNet将残差块设计为H(x) = F(x) + x，其直接把恒等映射作为网络的一部分，只要F(x) = 0，便得到了恒等映射。而此时F(x) = H(x) - x 称为残差函数，就是当前残差块的学习目标（学习出这样一个F(x)函数满足如图输出）</li><li>值得一提的是，一个残差块中应该至少有两层（中间要包含一个非线性激活），否则就会出现如下情况，这显然是没有用的工作<br><img src="/images/resnet/no_use.png" alt="plain_error"></li></ul><h2 id="Deeper-bottleneck-architecture"><a href="#Deeper-bottleneck-architecture" class="headerlink" title="Deeper bottleneck architecture"></a><strong>Deeper bottleneck architecture</strong></h2><ul><li>当神经网络层数进一步增多时，参数的增长会带来很大的计算开销。此时可以考虑使用1*1的卷积核暂时减少通道数来减少整个网络的数据规模<br><img src="/images/resnet/deeper.png" alt="plain_error"></li></ul><h2 id="Analysis-of-Deep-Residual-Networks"><a href="#Analysis-of-Deep-Residual-Networks" class="headerlink" title="Analysis of Deep Residual Networks"></a><strong>Analysis of Deep Residual Networks</strong></h2><ul><li>基本BP算法流程如下<br><img src="/images/resnet/bp.jpg" alt="plain_error"></li><li>残差块的反向传播过程较好地解释了残差网络避免梯度消失原因，具体推导过程如下</li><li>推导中忽略偏置项和激活函数<br><img src="/images/resnet/res_bp.png" alt="plain_error"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/resnet/cover.jpg&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Residual-Network&quot;&gt;&lt;a href=&quot;#Residual-Network&quot; class=&quot;headerlink&quot; title=&quot;Res</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="papers" scheme="http://example.com/tags/papers/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Residual-learning" scheme="http://example.com/tags/Residual-learning/"/>
    
  </entry>
  
  <entry>
    <title>GAN #1</title>
    <link href="http://example.com/2021/12/01/Gan0/"/>
    <id>http://example.com/2021/12/01/Gan0/</id>
    <published>2021-12-01T07:56:32.031Z</published>
    <updated>2021-12-01T07:56:32.031Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/gan/cover.png" alt="$cover"></p><h1 id="Generative-Adversarial-Nets"><a href="#Generative-Adversarial-Nets" class="headerlink" title="Generative Adversarial Nets"></a>Generative Adversarial Nets</h1><p>Gan利用对抗的方法，提出了生成式模型的新框架。它需要同时训练两个模型（生成模型G和判别模型D），G用于捕获数据的分布，而D需要判别出一个样本是来自训练集还是生成模型。生成模型的目标是尽最大可能让判别模型犯错（无法成功判别数据的来源），G和D在本文中被定义为多层感知机，整个系统通过反向传播来进行训练。</p><h2 id="AN-analogy-to-GAN"><a href="#AN-analogy-to-GAN" class="headerlink" title="AN analogy to GAN"></a><strong>AN analogy to GAN</strong></h2><p>在生成对抗网络框架中，生成模型与判别互相对抗。可以把生成模型类比为造假币者，判别模型类比为警察。生成模型试图制造假币骗过判别模型，而判别模型努力区分假币。二者在这样的对抗中不断学习提升各自的水平，直到生成模型的造的假币和真的一模一样，判别器无法区分。另外，警察进步不能过大或过小。进步过大时，造假者直接被一锅端，无法继续造假钞；进步过小时，造假者不需进步也能骗过警察，则没有动力进步</p><h2 id="Adversarial-nets"><a href="#Adversarial-nets" class="headerlink" title="Adversarial nets"></a><strong>Adversarial nets</strong></h2><ul><li><p>对抗网络认为数据集代表着一个联合分布，每一个样本都可以由高维随机变量表示。假设数据集是许多张2*2大小的黑白图片，每张图片有四个像素点，于是将该分布看作四维随机变量的分布，每一维代表着一个像素的取值（黑白只取0或1）<br><img src="/images/gan/mrv.jpg"></p></li><li><p>在让生成模型学习数据集代表了分布之前，首先定义一个符合高斯分布的先验噪声Z，生成模型就是要学习把Z映射成为数据集代表的分布，MLP理论上可以拟合这样一个函数来完成目标。生成器以Z为输入，输出一个尽量符合数据集分布的样本  </p></li><li><p>判别器也是一个MLP，判别器以数据集或生成器生产的样本为输入，输出一个标量（0：生成器生成的样本，1：真实样本，判别器的输出介于[0,1]），判别样本的真伪。判别器要学习一个二分类任务  </p></li><li><p>D与G对于同一个目标函数采取相反的优化方式：<br><img src="/images/gan/obj_func.png"><br>在不同分布里采样计算后得到期望和，生成器和鉴别器分别要调整参数最大化和最小化这一期望和，体现了对抗的过程，D尽量区分生成的数据和真实数据，G尽量使得生成的数据和真实数据难以区分</p></li><li><p>下图展示了对抗网络训练过程中，各个成分的变化：<br><img src="/images/gan/graph_proc.png"><br>Z为高斯噪声，绿色线代表G生成数据的概率密度函数，黑色线代表真实数据的概率密度函数，蓝色代表D输出标量的函数<br>（a）G将Z随即映射为另一个分布，与真实分布存在一定差距，此时D未经学习，分类能力弱<br>（b）固定G，训练D，D分类能力明显上升<br>（c）固定D，训练G，G学习到把Z向真实数据分布映射<br>（d）反复多轮后，G映射的分布与真实数据相同，判别器无法区分</p></li><li><p>对抗网络算法流程如下：<br><img src="/images/gan/algorithm.png"><br>先更新D，再更新G，G只与目标函数中后半段有关。k是一个超参数，不能太大也不能大小。取太大判别器训练得太好，取太小判别器变化太小</p></li></ul><h2 id="Theoretical-results"><a href="#Theoretical-results" class="headerlink" title="Theoretical results"></a><strong>Theoretical results</strong></h2><ul><li>理论上，对抗网络存在全局最优解：生成器映射的分布等于真实数据分布</li><li>对抗网络算法可以求解目标函数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/gan/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Generative-Adversarial-Nets&quot;&gt;&lt;a href=&quot;#Generative-Adversarial-Nets&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="papers" scheme="http://example.com/tags/papers/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Generative-Model" scheme="http://example.com/tags/Generative-Model/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Sequential Model</title>
    <link href="http://example.com/2021/11/30/d2l_9/"/>
    <id>http://example.com/2021/11/30/d2l_9/</id>
    <published>2021-11-30T08:41:29.526Z</published>
    <updated>2021-11-30T08:41:29.526Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Sequential-Model"><a href="#Sequential-Model" class="headerlink" title="Sequential Model"></a>Sequential Model</h1><h2 id="Basic-knowledge"><a href="#Basic-knowledge" class="headerlink" title="Basic knowledge"></a><strong>Basic knowledge</strong></h2><p>序列模型是考虑时间信息的模型</p><ul><li><p>序列数据</p><ul><li>数据带有时序结构，如电影的评价随时间变化<ul><li>电影拿奖后评分上升</li><li>导演、演员负面报道后评分下降</li></ul></li></ul></li><li><p>统计工具  </p><ul><li>将序列中每个元素看作随机变量，显然他们不是独立的<br><img src="/images/d2l/9/1.png"></li><li>在实际操作中，时序序列一般只能正向建模去预测<br><img src="/images/d2l/9/2.png"></li><li>要使用序列模型预测T时刻x的概率，核心是求T时刻的条件概率（似然），这里的f可看作神经网络，神经网络将训练集建模。自回归指的是用数据对见过的数据建模（因为最后预测也是在预测相同的数据），与非序列模型用数据对独立于数据的标签建模不同。<br><img src="/images/d2l/9/3.png"></li><li>具体如何建模？<ul><li>马尔科夫假设<br>当前预测的数据只跟过去的tau个数据相关，tau是一个固定常数。假设x是标量数据，此时只需要将其看作回归问题，使用MLP把tau个x当作特征训练得到t时刻标量x。MLP进行梯度优化的过程便是最大化似然概率的过程<br><img src="/images/d2l/9/4.png"></li><li>潜变量模型<br>引入一个可不断更新的潜变量用于概括历史信息，使得建模更加简单（RNN）<br><img src="/images/d2l/9/5.png"></li></ul></li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ul><li>马尔可夫假设+MLP<br>```python<br>import torch<br>from torch import nn<br>from torch.utils.data import TensorDataset<br>from torch.utils.data.dataloader import DataLoader<br>from torch import optim<br>import math</li></ul><h1 id="使用正弦函数加上噪声生成序列数据"><a href="#使用正弦函数加上噪声生成序列数据" class="headerlink" title="使用正弦函数加上噪声生成序列数据"></a>使用正弦函数加上噪声生成序列数据</h1><p>T=1000</p><p>time=torch.arange(1,T+1,dtype=torch.float32)<br>data=torch.sin(0.01*time)+torch.normal(0,0.1,time.shape)</p><h1 id="将数据映射为数据对"><a href="#将数据映射为数据对" class="headerlink" title="将数据映射为数据对"></a>将数据映射为数据对</h1><p>tau=4<br>labels=data[tau:].view(-1,1)<br>features=torch.zeros(T-tau,tau)<br>for i in range(tau):<br>    features[:,i]=data[i:T-tau+i]</p><p>train_dataset=TensorDataset(features[:600],labels[:600])<br>test_dataset=TensorDataset(features[600:],labels[600:])</p><p>train_iter=DataLoader(train_dataset,batch_size=16)<br>test_iter=DataLoader(test_dataset,batch_size=16)</p><p>net=nn.Sequential(<br>    nn.Linear(4,32),<br>    nn.Dropout(0.1),<br>    nn.ReLU(),<br>    nn.Linear(32,16),<br>    nn.ReLU(),<br>    nn.Linear(16,1)<br>    )<br>loss_f=nn.MSELoss()<br>opt=optim.Adam(net.parameters())</p><p>try:<br>    net.load_state_dict(torch.load(“9.params”))</p><p>except:<br>    for epoch in range(100):<br>        train_loss=[]<br>        test_loss=[]<br>        for X,y in train_iter:<br>            out=net(X)<br>            l=loss_f(out,y)</p><pre><code>        l.backward()        train_loss.append(l.item())        opt.step()        opt.zero_grad()    with torch.no_grad():        for X,y in test_iter:            out=net(X)            l=loss_f(out,y)            test_loss.append(l.item())    print(f"{epoch+1},{sum(train_loss)}  {sum(test_loss)}")torch.save(net.state_dict(),"9.params")</code></pre><h1 id="使用测试集预测"><a href="#使用测试集预测" class="headerlink" title="使用测试集预测"></a>使用测试集预测</h1><p>from matplotlib import pyplot as plt<br>t=600<br>steps=396</p><p>plt.plot([i for i in range(t,t+steps)],net(features[600:]).view(-1).detach().numpy())</p><h1 id="使用预测值进行多步预测"><a href="#使用预测值进行多步预测" class="headerlink" title="使用预测值进行多步预测"></a>使用预测值进行多步预测</h1><p>win=[math.sin(i*0.01) for i in range(t-4,t)]<br>true=[]<br>pred=[]<br>for i in range(steps):<br>    X=torch.tensor(win,dtype=torch.float32)<br>    out=net(X)<br>    truth=math.sin((t+i)*0.01)<br>    true.append(truth);pred.append(out.item())<br>    # print(out.item(),t)<br>    win.pop(0)<br>    win.append(out)</p><p>plt.plot([i for i in range(t,t+steps)],pred)<br>plt.plot([i for i in range(t,t+steps)],true)<br>plt.show()<br>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Sequential-Model&quot;&gt;&lt;a href=&quot;#Sequential-Model&quot; class=&quot;headerlink&quot; title=&quot;Sequ</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Basic Pytorch</title>
    <link href="http://example.com/2021/11/28/d2l_8/"/>
    <id>http://example.com/2021/11/28/d2l_8/</id>
    <published>2021-11-28T09:15:03.446Z</published>
    <updated>2021-11-28T09:15:03.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Basic-Pytorch"><a href="#Basic-Pytorch" class="headerlink" title="Basic Pytorch"></a>Basic Pytorch</h1><ul><li>模型构造</li></ul><pre><code class="python">import torch from torch import nnnet=nn.Sequential(nn.Linear(20,256),nn.ReLU(),nn.Linear(256,10))X=torch.normal(0,1,size=(1,20))print(net(X))class MLP(nn.Module):    def __init__(self):        super().__init__()        self.rand_weight=torch.randn((20,64),requires_grad=False,dtype=torch.float32)        self.hidden=nn.Sequential(nn.Linear(64,128),nn.ReLU(),nn.Linear(128,256))        self.out=nn.Linear(256,10)    def forward(self,X):        X=X@self.rand_weight+1        X=nn.ReLU()(self.hidden(X))        X=self.out(X)        # 下面这个过程流不会计入计算图        with torch.no_grad():            while torch.abs(X).sum()&gt;1:                X/=2        return X.sum()net=MLP()print(net(X))</code></pre><ul><li>参数管理</li></ul><pre><code class="python">import torchfrom torch import nnnet=nn.Sequential(nn.Linear(4,8),nn.ReLU(),nn.Linear(8,1))X=torch.rand(size=(2,4))# 访问参数# 访问网络中每一层，以及如何访问层中的参数print(net[0].state_dict(),net[1],net[2].bias.data)# 网络中的参数包括data和grad两部分，在这没做反向传播呢，所以梯度为Noneprint(net[2].weight.grad==None)# 将整个网络信息打印print(net)# 初始化参数# pytorch已经为我们做了比较好的默认初始化def init_xavier(m):    if(type(m)==nn.Linear):        nn.init.xavier_normal_(m.weight)        nn.init.zeros_(m.bias)def init_42(m):    nn.init.constant_(m.weight,42)    nn.init.constant_(m.bias,42)# 将初始化函数应用到net每一个子层，不止可以用在初始化上net[0].apply(init_xavier)print([i for i in net[0].parameters()])net[2].apply(init_42)print(net[2].weight,net[2].bias)# 更暴力的方法net[0].weight.data[:]+=100print(net[0].weight.data)# 参数绑定# 让某几层共享同样的参数shared=nn.Linear(8,8)net=nn.Sequential(nn.Linear(4,8),nn.ReLU(),shared,nn.ReLU(),shared,nn.Sigmoid(),nn.Linear(8,1))print(net[2]==shared)print(net[2].weight.data==net[4].weight.data)</code></pre><ul><li>自定义层</li></ul><pre><code class="python">import torchfrom torch import nn# 自定义层和自定义模型没本质区别class CenteredLayer(nn.Module):    def __init__(self):        super().__init__()        def forward(self,X):                return X-X.mean()layer=CenteredLayer()print(layer(torch.tensor([1,2,3,4],dtype=torch.float32)))# 带有参数的层class PrameterizedLayer(nn.Module):    def __init__(self,in_dim,out_dim):        super().__init__()        self.w=nn.Parameter(torch.randn((in_dim,out_dim)))        self.b=nn.Parameter(torch.randn((out_dim)))    def forward(self,X):                return X@self.w.data+self.b.datanet=PrameterizedLayer(2,8)print(net(torch.tensor([[1,2],[2,3],[3,4]],dtype=torch.float32)))</code></pre><ul><li>读写文件</li></ul><pre><code class="python">import torchfrom torch import nnx=torch.arange(4)# 加载和保存张量torch.save(x,'x_file')y=torch.load('x_file')print(x==y)# 加载和保存张量组成的数据结构a=torch.arange(5)b=torch.arange(5)torch.save([a,b],"list")torch.save({'a':a,'b':b},"dict")# 读取到内存会保持原数据结构print(torch.load("list"))print(torch.load("dict"))# 加载和保存模型的参数net=nn.Sequential(nn.Conv2d(1,2,5),nn.Flatten(),nn.Linear(288,64))print(net(torch.normal(0,0.5,size=(1,1,16,16))))print(net.state_dict())torch.save(net.state_dict(),'net.params')new_net=nn.Sequential(nn.Conv2d(1,2,5),nn.Flatten(),nn.Linear(288,64))new_net.load_state_dict(torch.load('net.params'))print(new_net==net)X=torch.normal(0,0.5,size=(1,1,16,16))print(new_net(X)==net(X))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Basic-Pytorch&quot;&gt;&lt;a href=&quot;#Basic-Pytorch&quot; class=&quot;headerlink&quot; title=&quot;Basic Pyto</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Numerical Stability &amp; Initialization</title>
    <link href="http://example.com/2021/11/28/d2l_7/"/>
    <id>http://example.com/2021/11/28/d2l_7/</id>
    <published>2021-11-28T06:18:56.312Z</published>
    <updated>2021-11-28T06:18:56.312Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="D2L-Numerical-Stability-amp-Initialization"><a href="#D2L-Numerical-Stability-amp-Initialization" class="headerlink" title="D2L: Numerical Stability &amp; Initialization"></a>D2L: Numerical Stability &amp; Initialization</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a><strong>Basic Knowledge</strong></h2><ul><li>数值的稳定性<ul><li>神经网络的梯度<br>求某一层的参数的梯度，直接就对损失函数关于该层参数求导,然后通过链式法则，化成d-t次的矩阵乘法<br><img src="/images/d2l/7/chain_d.png"></li><li>梯度爆炸与梯度消失<br>上述连续的乘法运算会带来两个问题：梯度爆炸与梯度消失<br><img src="/images/d2l/7/e_v.png"><br>梯度爆炸带来的问题：梯度值超过计算机可表示大小、对学习率敏感<br>梯度消失带来的问题：梯度值变为0（超出计算可表示精度的小浮点数）、无论如何选择学习率训练都没有进展、神经网络无法做到更深</li></ul></li><li>模型初始化<ul><li>如何让训练更加稳定？（不产生梯度消失和梯度爆炸）<br>要让梯度值保持在合理的范围内，一般有如下方法：<ul><li>将乘法变为加法（ResNet、LSTM）</li><li>归一化（梯度归一化、梯度裁剪）</li><li>选定合适的激活函数</li><li>合理的初始参数</li></ul></li><li>让每层的方差是一个常数<br><img src="/images/d2l/7/bn.png"></li><li>合理的权重初始化<ul><li>需要在一个合理值区间里随机初始参数<ul><li>远离最优解的地方损失函数很复杂（梯度很大）</li><li>最优解附近比较平缓 </li></ul></li></ul></li><li>Xavier初始化<br>使得输入空间的方差和输出空间的方差尽量相等</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;D2L-Numerical-Stability-amp-Initialization&quot;&gt;&lt;a href=&quot;#D2L-Numerical-Stabilit</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Weight Decay &amp; Dropout</title>
    <link href="http://example.com/2021/11/25/d2l_6/"/>
    <id>http://example.com/2021/11/25/d2l_6/</id>
    <published>2021-11-25T13:32:01.344Z</published>
    <updated>2021-11-25T13:32:01.344Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Weight-Decay-amp-Dropout"><a href="#Weight-Decay-amp-Dropout" class="headerlink" title="Weight Decay &amp; Dropout"></a>Weight Decay &amp; Dropout</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a><strong>Basic Knowledge</strong></h2><ul><li>权重衰退<br>权重衰退可以控制模型复杂度，使其复杂度不会太大，从而一定程度上避免过拟合<ul><li>使用均方范数作为硬性限制<br>通过限制参数的取值范围来控制模型容量，具体有如下例子<br>在限制参数向量范数的情况下优化损失函数，一般不会使用这种正则方式<br><img src="/images/d2l/6/hard_res.png"></li><li>使用均方范数作为柔性限制<br>上述硬性限制有一个等价方案，具体如下，这就是一般的正则化方法，其作用同样也是使得参数被限制在一个较小的范围<br><img src="/images/d2l/6/soft_res.png"><br>下面是正则项对最优解影响的一个演示<br>坐标轴分别是w的各个分量，圆线是等高线。<br>正则项给了另外一个梯度，把原始的损失函数算出的最优解往原点拉，必然会导致W的取值范围变小从而使模型复杂度降低，也就减小了过拟合。另外一种理解，正则项加入后优化目标就不再全局最优点了，所以肯定会减小训练集拟合程度，也就减小了过拟合<br>考虑为什么λ控制了正则项的重要程度，因为求偏导时λ会变成梯度前的常数项<br><img src="/images/d2l/6/effect.png"></li><li>参数更新<br>带正则项后参数更新过程如下，这也说明了为什么这种方法叫权重衰退：更新前先把权重减小，然后继续更新梯度<br><img src="/images/d2l/6/update.png"></li><li>注意<br>权重衰减也只在训练过程中使用，用来限制训练过程中的参数，在最终的验证过程中，指标还是原先的损失函数</li></ul></li><li>丢弃法<ul><li>动机<br>一个好的模型需要对输入数据加入扰动鲁棒，使用有噪音的数据等价于Tikhonov正则。丢弃法就是在层之间加入噪音，丢弃法也可以看作一个正则</li><li>无偏差地加入噪音<br>丢弃法就是加入了无偏噪音<br><img src="/images/d2l/6/noise.png"></li><li>使用丢弃法  <ul><li>对其发作用域隐藏层地输出上，即随机将某些神经元的输出置零且其它输出按上述公式增大</li><li>丢弃法只在训练过程中使用，测试和验证过程中不使用，这样保证了确定的输出</li><li>丢弃法常用于全连接层</li></ul></li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ul><li>权重衰减从零实现</li></ul><pre><code class="python">import torchfrom torch import nn,optimfrom d2l import *# 训练数据设置比较小，容易过拟合num_train=20num_test=100num_inputs=200batch_size=5true_w,true_b=torch.ones(num_inputs)*0.01,0.05train_data=synthetic_data(true_w,true_b,num_train)train_iter=data_loader(train_data,batch_size)test_data=synthetic_data(true_w,true_b,num_test)test_iter=data_loader(test_data,batch_size)# for X,y in train_iter:#     print(X,y)w=torch.normal(0,1,size=true_w.shape,requires_grad=True)b=torch.zeros(1,requires_grad=True)# L2正则def L2_penalty(lambada,w):    return torch.sum(w**2)/2*lambadadef liner_reg(w,b,X):    return torch.matmul(X,w)+bdef net(X):    return liner_reg(w,b,X)def squared_loss_L2(y_hat,y):    loss=(y_hat.view(y.shape)-y)**2/2/len(y)    return (loss+L2_penalty(0.5,w)).sum()opt=optim.SGD([w,b],lr=0.01)train(100,squared_loss_L2,opt,net,train_iter,test_iter)</code></pre><ul><li>权重衰减简洁实现</li></ul><pre><code class="python">net=nn.Sequential(nn.Linear(num_inputs,1))loss_f=nn.MSELoss()# weight_decay代表了L2范数前面的λ系数# 权重衰减系数很小时，在当前数据集下过拟合非常明显# 权重衰减系数很大时，欠拟合则会非常明显opt=optim.SGD(net.parameters(),lr=0.01,weight_decay=1.2)train(100,loss_f,opt,net,train_iter,test_iter)# 其它范数的正则pytorch没有直接的实现# 手动实现也很简单</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Weight-Decay-amp-Dropout&quot;&gt;&lt;a href=&quot;#Weight-Decay-amp-Dropout&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Modle Selection</title>
    <link href="http://example.com/2021/11/24/d2l_5/"/>
    <id>http://example.com/2021/11/24/d2l_5/</id>
    <published>2021-11-24T09:15:12.949Z</published>
    <updated>2021-11-24T09:15:12.949Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Modle-Selection"><a href="#Modle-Selection" class="headerlink" title="Modle Selection"></a>Modle Selection</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a><strong>Basic Knowledge</strong></h2><ul><li>训练误差和泛化误差  <ul><li>训练误差：模型在训练数据上的误差（不太关心）</li><li>泛化误差：模型在新数据上的误差（很关心）</li></ul></li><li>验证数据集和测试数据集<ul><li>验证数据集<br>用于在训练过程中评估模型好坏的数据集，一般从训练集中划分出一部分，验证数据集不能作为训练集让模型训练，用来动态调整模型超参数</li><li>测试数据集<br>模型最终训练完毕后，使用测试集测试模型泛化能力，<strong>不能使用测试集来调整模型超参数</strong>，大多数情况下不会被打上标签</li></ul></li><li>K-折交叉验证<br>通常情况下，我们都没有足够富裕的数据去从训练集中划分验证集，这是使用K-折交叉验证能较简单的解决问题<ul><li>思想：一般情况将K折交叉验证用于模型调优，找到使得模型泛化性能最优的超参值。找到后，在全部训练集上重新训练模型，并使用独立验证集对模型性能做出最终评价。</li><li>算法：K折就将训练集分为K块，训练代价为原来的K倍<ol><li>将原始数据集划分为相等的K部分（“折”）</li><li>将第i部分作为验证集，其余作为训练集</li><li>训练模型，计算模型在验证集上的准确率</li><li>每次用不同的部分i作为验证集，重复步骤2和3 K次</li><li>将平均准确率作为使用当前超参时的模型准确率</li><li>找到一个较好的超参数后，再用全部训练集训练模型，并在一个全新的验证集上验证，不用调超参数，达到一个较好的验证准确率时，直接去测试</li></ol></li></ul></li><li>过拟合和欠拟合<br><img src="/images/d2l/5/fitting.png"><ul><li>模型容量的影响<br>数据集复杂程度应该与模型复杂程度正相关，否则就会出现过拟合与欠拟合。举例来说，当模型很复杂而数据很简单时，模型可以直接就把所有数据记住而丧失泛化能力；而模型过于简单时，如感知机模型，无法正确划分异或的数据<br>模型足够复杂时，有其他手段减少过拟合；模型太简单没前途<br><img src="/images/d2l/5/capacity.png"></li></ul></li><li>估计模型容量<br>模型种类确定时（如神经网络），模型容量由两个因素估计：参数个数、参数取值范围 </li><li>数据复杂度<br>有多个重要因素：<ul><li>样本个数</li><li>特征个数</li><li>时间、空间结构</li><li>多样性</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Modle-Selection&quot;&gt;&lt;a href=&quot;#Modle-Selection&quot; class=&quot;headerlink&quot; title=&quot;Modle </summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Perceptron</title>
    <link href="http://example.com/2021/11/24/d2l_4/"/>
    <id>http://example.com/2021/11/24/d2l_4/</id>
    <published>2021-11-24T08:09:16.313Z</published>
    <updated>2021-11-24T08:09:16.313Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Perceptron"><a href="#Perceptron" class="headerlink" title="Perceptron"></a>Perceptron</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a><strong>Basic Knowledge</strong></h2><ul><li>感知机  <ul><li>模型<br>感知机只比线性分类多了一个激活函数，激活函数为单层感知机带来了分类能力，为多层感知机带来了非线性因素<br><img src="/images/d2l/4/perceptron.png"></li><li>训练<br>训练感知机等价于批量大小为1的梯度下降，按顺序逐个取样本，与随机梯度下降不同<br><img src="/images/d2l/4/train_p.png"></li><li>单层感知机无法解决异或问题，他只能产生线性分割面，这导致了第一次AI寒冬</li></ul></li><li>多层感知机<ul><li>多层感知机由多个感知机组成，分为输入层、隐藏层、输出层，层内不连接，层间全连接<br><img src="/images/d2l/4/mlp.png"></li><li>每个感知机输出后要经过一个非线性的激活函数，否则多层感知机等价于单层感知机</li><li>常用激活函数：Sigmoiod、Tanh、ReLU，性能都没太大区别，ReLU计算更容易，如果没有特别的想法，用ReLU就行</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ul><li>从零实现</li></ul><pre><code class="python">from torch import nn,optimtrain_iter,_=LoadData(256)num_in,num_out,num_h=784,10,256# 隐层参数w1=torch.randn(num_in,num_h,requires_grad=True)b1=torch.zeros(num_h,requires_grad=True)# 输出层参数w2=torch.randn(num_h,num_out,requires_grad=True)b2=torch.zeros(num_out,requires_grad=True)params=[w1,b2,w1,b2]loss_f=nn.CrossEntropyLoss()opt=optim.SGD(params,lr=0.001)def ReLU(X):    a=torch.zeros_like(X)    return torch.max(X,a)def Net(X:Tensor):    X=X.view(-1,num_in)    # @被重载为了矩阵乘法    X=ReLU(X@w1+b1)    return X@w2+b2def Train():    for epoch in range(50):        loss=0        for X,y in train_iter:            X=X.view(-1,784)            out=Net(X)            l=loss_f(out,y)            l.backward()            opt.step()            opt.zero_grad()            loss=l.item()        print(f"{epoch},{loss}")</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Perceptron&quot;&gt;&lt;a href=&quot;#Perceptron&quot; class=&quot;headerlink&quot; title=&quot;Perceptron&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Softmax Regression</title>
    <link href="http://example.com/2021/11/23/d2l_3/"/>
    <id>http://example.com/2021/11/23/d2l_3/</id>
    <published>2021-11-23T14:29:44.147Z</published>
    <updated>2021-11-23T14:29:44.147Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a><strong>Basic Knowledge</strong></h2><ul><li>softmax操作子<br>将输出变为一个概率分布（保证非负性与归一性）<br><img src="/images/d2l/3/softmax.png"></li><li>交叉熵损失<br>用于衡量两个概率分布的区别,将softmax输出的分布与one-hot形式的标签作为两个分布<br><img src="/images/d2l/3/cross_entropy.png"></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ul><li>数据集</li></ul><pre><code class="python">import torchimport torchvisionfrom torch.utils import datafrom torchvision import transformsdef LoadData(batch_size,resize=None):    # 用于把图片转为Tensor，会自动归一化    trans=[transforms.ToTensor()]    if resize:        trans.insert(0,transforms.Resize(resize))    trans=transforms.Compose(trans)        train_data=torchvision.datasets.FashionMNIST(        root="./dataset",train=True,        transform=trans,download=True    )    test_data=torchvision.datasets.FashionMNIST(        root="./dataset",train=False,        transform=trans,download=True    )    # print(test_data[0])        return (data.DataLoader(train_data,batch_size=batch_size,shuffle=True),        data.DataLoader(test_data,batch_size=batch_size,shuffle=False))    train_iter,test_iter=LoadData(256) </code></pre><ul><li>从零实现</li></ul><pre><code class="python"># 将图片展平num_inputs=1*28*28# 共有10类num_outputs=10w=torch.normal(0,0.01,size=(num_inputs,num_outputs),requires_grad=True)b=torch.zeros(num_outputs,requires_grad=True)def Softmax(X):    # 成batch分子组成的向量    X_exp=torch.exp(X)    # 成batch个分母    partition=X_exp.sum(1,keepdim=True)    # 应用广播机制    return X_exp/partitiondef CrossEntropy(y_hat,y):    # 只有y为下标那一项起作用    # 按正常one_hot编码为0的项直接就没算了    # 一个batch的y_hat都取对应y中的值为下标那个    # 最终得到了整个batch中所有样本的损失    return -torch.log(y_hat[range(len(y_hat)),y]).sum()def Net(w,b,X):    return Softmax(torch.matmul(X,w)+b)def Sgd(params,lr):    with torch.no_grad():        for i in params:            i-=lr*i.grad            i.grad.zero_()def Train():    for epoch in range(50):        loss=0        for X,y in train_iter:            X=X.view(-1,784)            out=Net(w,b,X)            l=CrossEntropy(out,y)            l.backward()            # 学习率设置这么小是因为在损失函数或优化器中            # 没有除以batch_size,导致求的梯度会很大            Sgd([w,b],0.0001)            loss=l.item()        print(f"{epoch},{loss}")</code></pre><ul><li>简洁实现</li></ul><pre><code class="python">train_iter,test_iter=LoadData(256)# 将图片展平num_inputs=1*28*28# 共有10类num_outputs=10from torch import nn,optim# Flatten() 保留第零维度，其他全部展平net=nn.Sequential(nn.Flatten(),nn.Linear(num_inputs,num_outputs))loss_f=nn.CrossEntropyLoss()opt=optim.Adam(net.parameters())for epoch in range(50):    loss=0    for X,y in train_iter:        out=net(X)        l=loss_f(out,y)        l.backward()        opt.step()        opt.zero_grad()        loss=l.item()    print(f"{epoch},{loss}")</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Softmax-Regression&quot;&gt;&lt;a href=&quot;#Softmax-Regression&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>D2L: Linear Regression</title>
    <link href="http://example.com/2021/11/23/d2l_2/"/>
    <id>http://example.com/2021/11/23/d2l_2/</id>
    <published>2021-11-23T07:59:48.186Z</published>
    <updated>2021-11-23T07:59:48.186Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d2l/1/cover.png" alt="$cover"></p><h1 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a><strong>Basic Knowledge</strong></h2><ul><li>线性模型  <ul><li>基本的线性模型可抽象为如下表示,其可以看作一个单层单神经元的神经网络<br><img src="/images/d2l/2/l_model.png"></li><li>线性模型有显示解<br><img src="/images/d2l/2/ex_solution.png"></li></ul></li><li>优化<ul><li>梯度下降<br>需要注意的是梯度是t-1时刻得来的，而且梯度是t-1时刻样本点、标签值以及W参数值对应的梯度，因为他们都是损失函数中的因变量<br><img src="/images/d2l/2/grad_desc.png"></li><li>成批计算梯度<br>batch_size不能太大也不能太小。太小：并行计算难以发挥效果；太大：内存消耗增加、易陷入局部最优。batch_size是另一个重要的超参数。</li></ul></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ul><li>从零实现</li></ul><pre><code class="python">import randomimport torchfrom torch.utils.data.dataloader import DataLoadertrue_w=torch.tensor([2.2,3])true_b=torch.tensor([-1.9])num_examples=2500batch_size=50epoch=100learning_rate=0.01# 初始化参数w=torch.normal(0,0.01,true_w.shape,requires_grad=True)b=torch.zeros(true_b.shape,requires_grad=True)def SyntheticData(w,b,num_examples):    X=torch.normal(0,1,size=(num_examples,len(w)))    # 支持多维度、不同维度的矩阵乘法    # 直接加b用了广播机制    y=torch.matmul(X,w) + b    # 增加噪声，使得不能完全拟合    y+=torch.normal(0,0.01,y.shape)    return X,y.view(-1,1)# 生成小批量def DataIter(batch_size,features,labels):    num_examples=len(features)        indices=list(range(num_examples))    # 打乱顺序    random.shuffle(indices)    for i in range(0,num_examples,batch_size):        batch_indices=torch.tensor(            indices[i:min(i+batch_size,num_examples)]            )                # Tensor可以接受一个列表的下标来取值        yield features[batch_indices],labels[batch_indices]# 定义模型def LinReg(X,w,b):        return torch.matmul(X,w)+b# 定义损失函数def SquaredLoss(y_hat,y):    return (y_hat-y.view(y_hat.shape))**2/2/batch_size# 优化算法def sgd(params,lr,batch_size):    with torch.no_grad():        for param in params:            param-=lr*param.grad            param.grad.zero_()    features,labels=SyntheticData(true_w,true_b,num_examples)# 训练def Train():    for i in range(epoch):        e_loss=[]        for X,y in DataIter(batch_size,features,labels):            out=LinReg(X,w,b)            # 将batch_size个损失求和            l=SquaredLoss(y,out).sum()            l.backward()            sgd([w,b],learning_rate,batch_size)            e_loss.append(l.item())        print(f"{i+1},loss:{sum(e_loss)/num_examples}")Train()# 简单验证x=torch.tensor([108,2.666])print(true_w,w)print(true_b,b)print(LinReg(x,true_w,true_b).item())print(LinReg(x,w,b).item())</code></pre><ul><li>简洁实现</li></ul><pre><code class="python">import numpy as npimport torchfrom torch.utils import datafrom torch import nnfrom torch import optimtrue_w=torch.tensor([2.2,3])true_b=torch.tensor([-1.9])num_examples=5000def SyntheticData(w,b,num_examples):    X=torch.normal(0,1,size=(num_examples,len(w)))    y=torch.matmul(X,w)+b    y+=torch.normal(0,0.01,y.shape)    return X,y.view(-1,1)features,labels=SyntheticData(true_w,true_b,num_examples)# 使第一维成为两个Tensor的共同索引，所以两个Tensor的第一维size要相同# 用来组成dataloader可处理的形式dataset=data.TensorDataset(features,labels)data_iter=data.dataloader.DataLoader(dataset,shuffle=True,batch_size=150)net=nn.Sequential(nn.Linear(len(true_w),1,bias=True))loss_f=nn.MSELoss()opt=optim.SGD(net.parameters(),lr=0.01)for epoch in range(100):    e_loss=[]    for X,y in data_iter:        out=net(X)        l=loss_f(out,y)        e_loss.append(l.item())        l.backward()        opt.step()        opt.zero_grad()        print(f"{epoch+1} {sum(e_loss)}")x=torch.tensor([108,2.666])print(true_w,true_b)for i in net.parameters():    print(i)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/d2l/1/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Linear-Regression&quot;&gt;&lt;a href=&quot;#Linear-Regression&quot; class=&quot;headerlink&quot; title=&quot;Li</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Dive-Into-Deep-Learning" scheme="http://example.com/tags/Dive-Into-Deep-Learning/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>Transformer</title>
    <link href="http://example.com/2021/11/22/Transformer/"/>
    <id>http://example.com/2021/11/22/Transformer/</id>
    <published>2021-11-22T08:36:52.958Z</published>
    <updated>2021-11-22T08:36:52.958Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/transformer/transformer.jpg" alt="$cover"></p><h1 id="Attention-Is-All-Your-Need"><a href="#Attention-Is-All-Your-Need" class="headerlink" title="Attention Is All Your Need"></a>Attention Is All Your Need</h1><p>以往主流的序列转录(seq2seq)模型中常常基于包含Encoder与Decoder的复杂RNN或CNN，这些模型也会在Encoder与Decoder中使用Attention机制。<br>Transformer仅仅使用了Attention机制，完全没用到循环和卷积，将循环层换为了Multi-headed Attetion。Transformer训练速度更快，预测能力更好。  </p><hr><h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><ul><li>RNN难以并行计算计算效率低，Transformer可并行。</li><li>RNN带有时序信息，但在序列较长时，早期的信息可能在后期丢失。Attention可通过在输入序列中加入index增加时序，并且不会存在信息丢失问题。</li><li>用CNN可以替换掉RNN实现并行计算，但由于感受野的限制其依然存在难以对长序列进行建模的问题。Transformer中的Attention机制一次性看到所有的序列，消除了这一问题。</li><li>CNN可利用多个输出通道识别不一样的模式，在Transformer中使用Multi-headed Attetion，也实现了这样的特性。</li></ul><hr><h2 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h2><p>Transformer整体分为Encoder与Decoder两大部分。  </p><ul><li>Input Embedding/Output Embedding将词映射到向量。</li><li>Postoinal Encoding</li><li>Nx指有N个该块叠在一起。</li><li>Add表示残差连接，Norm表示正则处理。</li><li>在训练时，解码器的输入（outputs）是真实值(Ground Truth)；在测试时，输入（outputs）是前一时刻的输出。<br><img src="/images/transformer/architecture.png" alt="architecture"></li></ul><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>N=6，out_dim=input_dim=512。由两个子层组成，两个子层分别为Multi-headed Attetion和简单的MLP。每个子层使用残差连接和layer normalization。</p><blockquote><p>layer normalization and batch normalization</p><blockquote><p>batch:对每一个feature，将这个feature在一个batch中的所有数据的均值变为0方差变为1<br><img src="/images/transformer/batch_norm.png" alt="batch_norm"><br>layer:对每一个样本，将这个样本所有的特征均值变为0方差变为1<br><img src="/images/transformer/layer_norm.png" alt="layer_norm"><br>成sequence的normalization:<br>蓝为batch，黄为layer，取所有数据去做norm。阴影部分为样本实际长度（即该样本序列的seq_len），在实际长度外取全0。<br><img src="/images/transformer/seq_norm.png" alt="seq_norm"><br>使用layernormalization相对稳定一些。每个样本自己做均值方差再去norm。</p></blockquote></blockquote><hr><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>N=6,由三个子层组成，其中后两个子层Encoder一致，而第一个子层有所不同，其使用了Masked Multi-headed Attetion。在Decoder中还使用了自回归。当前的outputs输入是上一次的输出。在训练过程中，Decoder的输入outputs为ground truth，但在t时刻的输入不应包含t时刻之后的输入，所以第一个子层引入了masked机制。</p><hr><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><blockquote><p>Transformer使用了Scaled Dot-Product Attention。其将输入的一个seq进行融合输出一个等长的seq。<br><img src="/images/transformer/panaroma.png" alt="panaroma"><br>在融合时，每一个输出都考虑了其对应位置输入元素和seq中其他元素的相关度。Wq与Wk是两个参数矩阵，原始输入做矩阵运算后得到两个向量q、k，最后用内积运算即得到了原始输入的相关性（内积运算代表了余弦相似度）。<br><img src="/images/transformer/dot-product.png" alt="dot-product"><br>同理可计算出a1与自身及序列中所有元素的相关性，全部计算完成后输入到softmax层进行归一化。<br><img src="/images/transformer/to-softmax.png" alt="to-softmax"><br>利用一个新的参数矩阵Wv获得v1-v4。v与相关性系数的带权和得到b1。<br><img src="/images/transformer/b1.png" alt="b1"><br>同理，可以得到b2、b3、b4。<br><img src="/images/transformer/panaroma.png" alt="panaroma"><br>上述步骤可表示为矩阵运算。<br><img src="/images/transformer/use_matrix.png" alt="use_matrix"><br>最终的计算公式可如下表示。这里多了一个除以根号dk(input_dim)，这是因为向量(Transformer中dk=512)比较长时，内积绝对值可能会出现比较大的情况，这对梯度下降是不利的。<br><img src="/images/transformer/formula.png" alt="formula"> </p></blockquote><blockquote><p>Multi-headed Attetion可以看作是多通道的Attention。以2heads为例，计算过程如下，增加了多个参数矩阵。<br><img src="/images/transformer/multi-head.png" alt="multi-head"><br>在最后，将bi1与bi2一起其他的相应多通道b在特征维度拼接起来，为保证dim不变，利用一个新的参数矩阵Wo将输出元素的维度变为和输入相同。<br><img src="/images/transformer/concat.png" alt="concat"><br>一个线性层就可看作一个参数矩阵，所以上述两步操作可看作如下的过程。<br><img src="/images/transformer/liner-representatoin.png" alt="liner-representatoin"> </p></blockquote><hr><h3 id="Cross-Attention-in-Transformer"><a href="#Cross-Attention-in-Transformer" class="headerlink" title="Cross Attention in Transformer"></a>Cross Attention in Transformer</h3><p>Cross Attention指的是Encoder与Decoder之间的Attention机制。其V和K来自于Encoder，而Q来自于masked Attention。由于是masked，向Q输入的部分其seq_len会与V和K的不同，又因为其作为Q输入，所以cross-attention输出的seq_len会与之相同，所以Decoder的输入输出seq_len是相同的。<br><img src="/images/transformer/cross-attention.png" alt="cross-attention">  </p><hr><h3 id="Feed-Forward"><a href="#Feed-Forward" class="headerlink" title="Feed-Forward"></a>Feed-Forward</h3><p>只有一个MLP分别去作用于seq中的每个词，<br>图中MLP权重是相同的，也不需要把Encoder的输出合并输入到大的MLP。因为这里只是想要把原始维度投影到想要的另一个维度，其信息融合已经在Encoder中做完了。<br><img src="/images/transformer/feed-forward.png" alt="feed-forward"></p><hr><h3 id="Embedding-and-Softmax"><a href="#Embedding-and-Softmax" class="headerlink" title="Embedding and Softmax"></a>Embedding and Softmax</h3><p>编码器要有embedding，解码器要有embedding，softmax层之前有一个Liner层，这三个层共享权重。</p><hr><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><p>为了给Attention加上时序信息，给输入加上位置信息。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/transformer/transformer.jpg&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Attention-Is-All-Your-Need&quot;&gt;&lt;a href=&quot;#Attention-Is-All-Your-Need</summary>
      
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="papers" scheme="http://example.com/tags/papers/"/>
    
    <category term="Neural-Network" scheme="http://example.com/tags/Neural-Network/"/>
    
    <category term="Seq2Seq-Model" scheme="http://example.com/tags/Seq2Seq-Model/"/>
    
  </entry>
  
  <entry>
    <title>C# Asynchronous programming #3</title>
    <link href="http://example.com/2021/11/22/CSAsync3/"/>
    <id>http://example.com/2021/11/22/CSAsync3/</id>
    <published>2021-11-22T08:36:21.830Z</published>
    <updated>2021-11-22T08:36:21.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/CSAsynchronousProgramming/cover.png" alt="$cover"></p><h1 id="C-Asynchronous-programming-3"><a href="#C-Asynchronous-programming-3" class="headerlink" title="C# Asynchronous programming #3"></a>C# Asynchronous programming #3</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><strong>Thread</strong></h2><h3 id="Use-Thread-in-Applications"><a href="#Use-Thread-in-Applications" class="headerlink" title="Use Thread in Applications"></a><strong>Use Thread in Applications</strong></h3><ul><li>在带界面的WPF、UWP、WinForm等程序种，若主线程执行耗时的操作，就会导致整个程序无响应。因为主线程同时还要处理消息循环，而渲染和鼠标键盘事件处理等工作都是在消息循环中执行的</li><li>针对这种耗时的操作，一种流行的做法使启用一个worker线程，执行完操作后再更新到UI</li><li>富客户端应用的线程模型通常是：<ul><li>UI控件只能从创建他们的线程来进行访问（通常是主线程）</li><li>当想从worker线程更新UI时，应该把请求交给UI线程</li></ul></li></ul><h3 id="Synchronization-Contexts"><a href="#Synchronization-Contexts" class="headerlink" title="Synchronization Contexts"></a><strong>Synchronization Contexts</strong></h3><ul><li>在System.ComponentModel下有一个抽象类：SynchronizationContext，它使得Thread Marshaling得到泛化<ul><li>Thread Marshaling：把一些数据的所有权从一个线程交给了另一个线程</li></ul></li></ul><h3 id="Thread-Pool"><a href="#Thread-Pool" class="headerlink" title="Thread Pool"></a><strong>Thread Pool</strong></h3><ul><li><p>当开始一个线程时，将花费数百微秒来组织一些内容（如一个新的局部变量栈），产生了开销</p></li><li><p>线程池可以节省这些开销：</p><ul><li>预先创建一个可循环使用的线程的池来减少创建新线程的开销</li></ul></li><li><p>线程池对于搞笑的并行编程和细粒度的并发是必不可少的</p></li><li><p>关于c#中的线程池需要注意以下几点：</p><ul><li>不可以设置池线程的<code>Name</code></li><li>池线程都是后台线程</li><li>阻塞池线程可能使性能降低</li><li>池线程优先级可以被自由的更改，当它被释放回池的时候优先级将被还原为正常状态</li><li>可以通过<code>IsThreadPoolThread</code>属性来判断是否为池线程</li><li><code>Task</code>也使用线程池</li></ul></li><li><p>线程池中的整洁</p><ul><li>线程池提供了另一个功能，即确保不会产生CPU超额订阅（活跃的线程数超过CPU核数），超额订阅对性能影响很大</li><li>CLR通过对任务排队并对其启动进行节流限制来避免线程池中的超额订阅</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/CSAsynchronousProgramming/cover.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-Asynchronous-programming-3&quot;&gt;&lt;a href=&quot;#C-Asynchronous-p</summary>
      
    
    
    
    <category term="C#" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Asynchronous-programming" scheme="http://example.com/tags/Asynchronous-programming/"/>
    
    <category term="CS-Threading" scheme="http://example.com/tags/CS-Threading/"/>
    
  </entry>
  
</feed>
